<!doctype html>
<html lang="ru">

<head>
    <meta charset="utf-8">
    <title>ECMAScript 6</title>
    <meta name="description" content="ECMAScript 6">
    <meta name="keywords" content="ECMAScript 6, es6, область видимости, let, const, ООП, наследование, модули, Promise">
    <meta name="author" content="Maks Hladki">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="shortcut icon" href="../../img/js-icon.ico" type="image/x-icon">
    <link rel="stylesheet" href="../../css/bundle.min.css">
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <section>
                    <h1>Стандарт ECMAScript 6</h1>
                    <h3>Разработка динамических веб приложений</h3>
                    <p>
                        <small>
                            Гладкий Максим Валерьевич /
                            <a href="https://github.com/MaksHladki/DDWA">github:MaksHladki</a>
                        </small>
                    </p>
                </section>
                <section>
                    <h2>Содержание лекции</h2>
                    <nav id="presentable-toc" class="table-content"></nav>
                </section>
            </section>
            <!-- Содержимое лекции -->
            <!-- Вступление -->
            <section>
                <h2>Долгие 10 лет</h2>
                <img src="img/history.png" alt="">
            </section>
            <section>
                <h2>Как вдруг...</h2>
                <blockquote>
                    17 июня 2015 года генеральное собрание Ecma International официально одобрило стандарт ECMA-262 версии 6.0
                </blockquote>
                <ul>
                    <li>Стандарт ECMA-262</li>
                    <li>ECMAScript 6</li>
                    <li>ECMAScript 2015</li>
                    <li>ECMAScript Harmony: улучшения после ECMAScript 5 (ES6 и ES7)</li>
                    <li>ECMAScript.next: кодовое название ECMAScript 6</li>
                </ul>
            </section>
            <!-- Блочная область видимости -->
            <section>
                <h1>Блочная область видимости</h1>
                <h3>(let и const)</h3>
            </section>
            <section>
                <section>
                    <h2>Оператор let</h2>
                    <blockquote>
                        Позволяет объявить локальную переменную с областью видимости, ограниченной текущим блоком кода
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]];

//var1, var2, …, varN - имя переменной 
//(любой допустимый идентификатор)

//value1, value2, …, valueN - значение переменной 
//(любое допустимое выражение)
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Блочная область видимости</h3>
                    <p>ES5</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
var apples = 5;
if (true) {
    var apples = 10;
    console.log(apples);//10 (внутри блока)
}

console.log(apples);//10 (снаружи блока то же самое)
                        </code>
                    </pre>
                    <p>ES6</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
let apples = 5;
if (true) {
    let apples = 10;
    console.log(apples);//10 (внутри блока)
}

console.log(apples);//5 (снаружи блока значение не изменилось)
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Видимость после объявления</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
console.log(a);//undefined
var a = 5;
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
console.log(a);//ReferenceError: a is not defined
let a = 5;
                        </code>
                    </pre>
                    <pre>
                    <code class="hljs javascript" data-trim>
let x;
let x;//SyntaxError: Identifier 'x' has already been declared
                    </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
if (true) {
    let apples = 10;
    console.log(apples);//10 (внутри блока)
}

console.log(apples);//ReferenceError: apples is not defined
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Использование в цикле</h3>
                    <p>ES5</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
for(var i=0; i<10; i++) {
    console.log(i);//0, 1, 2, 3, 4 ... 9
}

console.log(i);//10
                        </code>
                    </pre>
                    <p>ES6</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
for (let i = 0; i<10; i++) {
    console.log(i);//0, 1, 2, 3, 4 ... 9
}

console.log(i);//i is not defined	
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Замыкания</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function shooterBuilder() {
    let shooters = [];

    for (let i = 0; i < 10; i++) {
        shooters.push(function() {
            console.log(i);
        });
    }

    return shooters;
}

var x = shooterBuilder();
x[0]();//0
x[5]();//5
//При использовании var было бы 10 10
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Оператор const</h2>
                    <blockquote>
                        Значение констант не может быть изменено новым присваиванием и не может быть переопределено. Константы подчиняются области
                        видимости уровня блока
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
const name1 = value1 [, name2 = value2 [, ... [, nameN = valueN]]];

//nameN - имя константы (те же правила, что и для переменных)
//valueN - значение константы
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 1</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
const apple = 5;
apple = 10;//Uncaught TypeError: Assignment to constant variable
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
const user = {
  name: "Alex"
};

user.name = "Maks";//допустимо
user = 5;//Uncaught TypeError: Assignment to constant variable
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
const lit = 4;
lit = 5;//TypeError: Литерал изменить нельзя

const obj = { a: 1 };
obj.a = 2;//Значения внутри объекта изменить можно

console.log(obj);//{ a: 2 }
obj = { a: 3 };//TypeError: Ссылку менять нельзя

const arr = [1, 2, 3];
arr.push(4);//Значения внутри массива изменить можно

console.log(arr);//[1, 2, 3, 4]
arr = [4, 3, 2, 1];//TypeError: Ссылку менять нельзя
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Деструктуризация -->
            <section>
                <h1>Деструктуризация</h1>
                <h3>(destructuring assignment)</h3>
            </section>
            <section>
                <h2>Понятие деструктуризации</h2>
                <blockquote>
                    Особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части
                </blockquote>
                <ul>
                    <li>Деструктуризация позволяет привязывать данные при совпадении паттерна</li>
                    <li>Поддерживается для массивов и объектов</li>
                    <li>Деструктуризация устойчива к ошибкам и во многом похожа на поиск поля в объекте</li>
                    <li>Возвращает undefined, если что-то пошло не так</li>
                </ul>
            </section>
            <section>
                <section>
                    <h2>Деструктуризация массива</h2>
                    <pre>
                        <code class="hljs javascript" data-trim>
let [firstName, lastName] = ['Иван', 'Иванов'];
console.log(firstName);//Иван
console.log(lastName);//Иванов
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пропуск элементов</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
//первый и второй элементы не нужны
let [, , middleName] = "Иванов Иван Иванович (1971)".split(" ");
console.log(middleName);//Иванович
                        </code>
                    </pre>
                    <p>Первый и второй, а также все элементы после третьего никуда не записались, они были отброшены</p>
                </section>
                <section>
                    <h3>Оператор spread</h3>
                    <ul>
                        <li>Значением rest будет массив из оставшихся элементов</li>
                        <li>Вместо rest можно использовать другое имя переменной</li>
                        <li>Оператор spread - троеточие</li>
                        <li>Spread должен стоять только перед последним элементом</li>
                    </ul>
                    <pre>
                        <code class="hljs javascript" data-trim>
let [first, last, ...rest] = "Все ЛР должны быть сданы".split(" ");

console.log(first);//Все
console.log(last);//ЛР
console.log(rest);//["должны", "быть", "сданы"]
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Значения по умолчанию</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let [firstName, lastName] = [];
console.log(firstName);//undefined
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
let [firstName="Гость", lastName="Анонимный"] = [];
console.log(firstName);//Гость
console.log(lastName);  //Анонимный
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
function defaultLastName() {
    return Date.now() + '-visitor';
}

//lastName получит значение, соответствующее текущей дате:
let [firstName, lastName=defaultLastName()] = ["Вася"];
console.log(firstName);//Вася
console.log(lastName);//1436...-visitor
                            </code>
                        </pre>
                </section>
                <section>
                    <h3>Отделение объявления от присваивания</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let a, b;
[a, b] = [1, 2];

console.log(a);//1
console.log(b);//2
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Swapping</h3>
                    <pre>
                    <code class="hljs javascript" data-trim>
var a = 1;
var b = 3;
[a, b] = [b, a];

console.log(a);//3
console.log(b);//1
						</code>
					</pre>
                </section>
                <section>
                    <h3>Использование возвращающей функции</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function f() {
    return [1, 2];
}

var a, b; 
[a, b] = f();

console.log(a);//1
console.log(b);//2
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Работа c другими коллекциями</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
//Строки
var [a, b, c] = 'xyz';
console.log(a, b, c);//x y z
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
//Коллекции DOM элементов
var [link1, link2] = document.links;
console.log(link1.tagName);//A
console.log(link2.textContent);//Стандарт ECMAScript 6
                        </code>
                    </pre>
                </section>
            </section>
            <!-- деструктуризации объектов -->
            <section>
                <section>
                    <h2>Деструктуризация объектов</h2>
                    <ul>
                        <li>Указываем, какие свойства в какие переменные должны перейти</li>
                        <li>Объект справа – существующий объект</li>
                        <li>Список слева – список переменных, в которые записываются соответствующие свойства</li>
                    </ul>
                    <pre>
                        <code class="hljs javascript" data-trim>
let {var1, var2} = {var1:…, var2…}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let options = {
  title: "Меню",
  width: 100,
  height: 200
};

let {title, width, height} = options;

console.log(title);//Меню
console.log(width);//100
console.log(height);//200
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Использование возвращающей функции</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var calc = function(num) {
    return Math.pow(num, 2);
};

var { prop: x, pow: y = calc(x)} = { prop: 4 };
console.log(x, y);//4 16

var { prop: x, pow: y = calc(x)} = { prop: 4, pow: 10 };
console.log(x, y);//4 10
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Другое имя переменной</h3>
                    <pre>
                    <code class="hljs javascript" data-trim>
let options = {
    title: "Меню",
    width: 100,
    height: 200
};

let {width: w, height: h, title} = options;

console.log(title);//Меню
console.log(w);//100
console.log(h);//200
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Значение по умолчанию</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let options = {
    title: "Меню"
};

let {width=100, height=200, title} = options;

console.log(title);//Меню
console.log(width);//100
console.log(height);//200
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Combo: новое имя + значение по умолчанию</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let options = {
  title: "Меню"
};

let {width:w=100, height:h=200, title} = options;

console.log(title);//Меню
console.log(w);//100
console.log(h);//200
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Отделение объявления от присваивания</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var width, height;
({width, height} = {width: 100,height: 200});

console.log(width);//100
console.log(height);//200
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Использование конкретного имени</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let key = "title";
let { [key]: t } = {title: "Меню"};

console.log(t);//Меню
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <h2>Вложенные деструктуризации</h2>
                <pre>
                    <code class="hljs javascript" data-trim>
let options = {
    size: {
        width: 100,
        height: 200
    },
    items: ["Пончик", "Пирожное"]
};

let { title="Меню", 
      size: {width, height}, 
      items: [item1, item2] 
    } = options;

//Меню 100 200 Пончик Пирожное
console.log(title);//Меню
console.log(width);//100
console.log(height);//200
console.log(item1);//Пончик
console.log(item2);//Пирожное
                    </code>
                </pre>
            </section>
            <!-- Функции -->
            <section>
                <h1>Функции</h1>
            </section>
            <section>
                <section>
                    <h2>Параметры по умолчанию</h2>
                    <pre>
                        <code class="hljs javascript" data-trim>
function [name]([param1[= defaultValue1][, ..., paramN[= dValueN]]])
{
    //function's body
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Простой пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function multiply(a, b = 1) {
    return a*b;
}

console.log(multiply(5));//5
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример с undefined</h3>
                    <blockquote>
                        Даже при явном указании 'undefined' параметру присваивается значение по умолчанию
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
function multiply(a, b = 1) {
    return a*b;
}

multiply(5, undefined);//5
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Вычисление во время вызова</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function append(value, array = []) {
    array.push(value);
    return array;
}

append(1);//[1]
append(2);//[2]
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример с функцией</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
}

function print(number = getRandomInt(10, 100)){
    console.log(number);
}

print();//29
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Оператор spread</h3>
                    <blockquote>
                        В отличие от arguments, rest - это массив, а значит, можно использовать методы map, forEach и т.д.
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
function printName(firstName, lastName, ...rest) {
    console.log(firstName + ' ' + lastName + ' - ' + rest);
    console.log(rest);
}

printName('Иван', 'Иванов', 'Иванович', '1959');
//Иван Иванов - Иванович,1959
//["Иванович", "1959"]
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Свойство name</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function getRandomInt(min, max) 
{ 
    return Math.floor(Math.random() * (max - min)) + min; 
} 

console.log(getRandomInt.name);//getRandomInt
getRandomInt.name = 'f'; 

console.log(getRandomInt.name);//getRandomInt 
console.log(f.name);//ReferenceError: f is not defined
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Блочная модель видимости</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var something = false;
if(something){
    console.log(getRandomInt(0, 10));
    function getRandomInt(min, max) {
       return Math.floor(Math.random() * (max - min)) + min;
    }
}

console.log(getRandomInt(0, 10));
//Uncaught TypeError: getRandomInt is not a function
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
var something = true;
if(something){
    console.log(getRandomInt(0, 10));//2
    function getRandomInt(min, max) {
       return Math.floor(Math.random() * (max - min)) + min;
    }
}

console.log(getRandomInt(0, 10));//9
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Стрелочные функции -->
            <section>
                <section>
                    <h2>Стрелочные функции</h2>
                    <blockquote>
                        Выражения имеют более короткий синтаксис, всегда анонимные и лексически привязанные к значению this
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
(param1, param2, paramN) => expression
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Особенности</h3>
                    <ul>
                        <li>
                            Лексическое связывание. Значения this, super и arguments определяются не тем, как стрелочные функции были вызваны, а тем,
                            как они были созданы
                        </li>
                        <li>
                            Неизменяемые this, super и arguments. Значения этих переменных внутри стрелочных функций остаются неизменными на протяжении
                            всего жизненного цикла функции
                        </li>
                        <li>Стрелочные функции не могут быть использованы как конструктор</li>
                        <li>Недоступность «собственного» значения переменной arguments, this ...</li>
                    </ul>
                </section>
                <section>
                    <h3>Короткая запись</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var faculties = [
  "ИТ",
  "ИЭФ",
  "ХТИТ"
];

var a = faculties.map(function(s){ return s.length });//[2,3,4]
var b = faculties.map( s => s.length);//[2,3,4]
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Еще пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let square = x => x*x;
console.log(square(3));//9
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
let sum = (x, y) => x + y;
console.log(sum(3,4));//7
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript">
let getObject = () => ({ brand: 'BMW' });
console.log(getObject());//Object {brand: "BMW"}
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
let func = () => 77;
console.log(func());//77
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Отсутствие this</h3>
                    <pre>
                    <code class="hljs javascript" data-trim>
var handler = {
    id: "123456",
    init: function() {
        document.addEventListener("click", ev => this.doSomething(ev.type));
        //this указывает на внешний контекст
    },
    doSomething: function(type) { 
        console.log("Handling " + type  + " for " + this.id);
    }
};
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Отсутствие arguments</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function foo() {
    var f = (i) => arguments[0]+i;
    //возмет arguments из функции foo
    console.log(f(2));
}

foo(1);//3
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Отсутствие запуска с new</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var a = new (function() {}); 
//переменной a будет присвоено значение экземпляра анонимной функции

var b = new (() => {}); 
//TypeError: (intermediate value) is not a constructor
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Строки -->
            <section>
                <h1>Строки</h1>
            </section>
            <section>
                <section>
                    <h2>Шаблонные строки</h2>
                    <blockquote>
                        Выглядят как обычные строки, за исключением того, что обернуты символами обратных кавычек
                        <span class="highlight-blue">
                            <b>`</b>
                        </span>
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
`строка текста`
`строка текста 1
 строка текста 2`
`строка текста ${выражение} строка текста`
tag `строка текста ${выражение} строка текста`
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Многострочные литералы</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
console.log(`string text line 1
string text line 2`);
//"string text line 1
// string text line 2"
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Интерполяция выражений</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let arg1 = 2;
let arg2 = 3;

console.log(`${arg1} + ${arg2} = ${arg1 + arg2}`);//2 + 3 = 5
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Еще пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function authorize(user, action) {
    if (!user.hasPrivilege(action)) {
        throw new Error(
        `Пользователю ${user.name} не разрешено ${action}.`);
    }
}
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
const up = (str) => str.toUpperCase();
let str = `this is ${ up('string') } in uppercase`;

console.log(str);//this is STRING in uppercase
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Вложенная интерполяция</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
const up = (str) => str.toUpperCase();
let user = 'user';
let str = `these ${up(`${user}s`)} are great`;
console.log(str);//these USERS are great
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Улучшенная поддержка юникода</h3>
                    <blockquote>
                        Используется кодировка UTF-16. На хранение одного символа необходимо 2 байта
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
console.log( '我'.length );//1
console.log( '𩷶'.length );//2

//расширенная поддержка метасимволов, математических символов 
//и смайликов
console.log( '𝒳'.length );//2, MATHEMATICAL SCRIPT CAPITAL X
console.log( '😂'.length );//2, FACE WITH TEARS OF JOY
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Новые методы</h3>
                    <ul>
                        <li>str.includes(s)</li>
                        <li>str.endsWith(s)</li>
                        <li>str.startsWith(s)</li>
                        <li>str.repeat(count)</li>
                    </ul>
                </section>
                <section>
                    <h3>Метод includes</h3>
                    <blockquote>
                        Проверяет, включает ли одна строка str в себя другую строку searchString, возвращает true/false
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
str.includes(searchString[, position])
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
var str = 'To be, or not to be, that is the question.';
console.log(str.includes('To be'));       //true
console.log(str.includes('question'));    //true
console.log(str.includes('nonexistent')); //false
console.log(str.includes('To be', 1));    //false
console.log(str.includes('TO BE'));       //false
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Метод endsWith</h3>
                    <blockquote>
                        Возвращает true, если строка str заканчивается подстрокой searchString
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
str.endsWith(searchString[, position])
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
var str = 'To be, or not to be, that is the question.';

console.log(str.endsWith('question.'));//true
console.log(str.endsWith('to be'));    //false
console.log(str.endsWith('to be', 19));//true
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Метод startsWith</h3>
                    <blockquote>
                        Возвращает true, если строка str начинается со строки searchString
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
str.startsWith(searchString[, position])
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
var str = 'To be, or not to be, that is the question.';

console.log(str.startsWith('To be'));        //true
console.log(str.startsWith('not to be'));    //false
console.log(str.startsWith('not to be', 10));//true
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Метод repeat</h3>
                    <blockquote>
                        Повторяет строку str count раз
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
str.repeat(count)
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
'abc'.repeat(-1);   //RangeError
'abc'.repeat(0);    //''
'abc'.repeat(1);    //'abc'
'abc'.repeat(2);    //'abcabc'
'abc'.repeat(3.5);  //'abcabcabc' (count will be converted to integer)
'abc'.repeat(1/0);  //RangeError
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Функции шаблониазции -->
            <section>
                <section>
                    <h2>Функции шаблонизации</h2>
                    <blockquote>
                        Процесс использования своей функции шаблонизации для строк
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
let str = func`моя строка`;
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function f(strings, ...values) {
    console.log(JSON.stringify(strings));//["Sum of "," + "," =\n ","!"]
    console.log(JSON.stringify(strings.raw));//["Sum of "," + "," =\\n ","!"]
    console.log(JSON.stringify(values));//[3,5,8]
}

let arg1 = 3;
let arg2 = 5;
let str = f`Sum of ${arg1} + ${arg2} =\n ${arg1 + arg2}!`;
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Необрабатываемые строки</h3>
                    <blockquote>
                        Статический метод Raw является теговой функцией для шаблонных строк и используется для получения необработанной строки из
                        шаблона
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
String.raw(callSite, ...substitutions)
String.raw`templateString`
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
String.raw`Привет\n Ответ = ${2+3}!`;
//"Привет\n Ответ = 5!"

//Экранирующие символы не имеют особого значения и
//обратные слеши будут присутствовать в выходной строке.
//Можно убедиться в этом, проверив свойство .length
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
function tag(strings, ...values) {
  return strings.raw[0];
}

tag`string text line 1 \n string text line 2`;
//"string text line 1 \n string text line 2"
//'\' и 'n' - это два символа
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Тип данных Symbol -->
            <section>
                <h1>Symbol</h1>
            </section>
            <section>
                <section>
                    <h2>Тип данных Symbol</h2>
                    <blockquote>
                        Уникальный и неизменяемый тип данных, который может быть использован как идентификатор для свойств объектов
                    </blockquote>
                    <blockquote>
                        Символьный объект — это объект-обертка для примитивного символьного типа
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
Symbol([описание])
//создается новый символ, 
//значение которого не равно любому другому объекту
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Методы</h3>
                    <table>
                        <tr>
                            <td>Symbol.for(key)</td>
                            <td>
                                ищет существующие символы по заданному ключу и возвращает его, если он найден. В противном случае создается новый символ
                                в глобальном реестре символов
                            </td>
                        </tr>
                        <tr>
                            <td>Symbol.keyFor(sym)</td>
                            <td>получает по разделяемому символу его ключ из глобального реестра символов</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>Пример 1</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var sym1 = Symbol();
var sym2 = Symbol("foo");
var sym3 = Symbol("foo");
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
var sym = Symbol("foo");
console.log(typeof sym);//symbol

var symObj = Object(sym);
console.log(typeof symObj);//object

console.log(Symbol("name") == Symbol("name"));//false
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let isAdmin = Symbol("isAdmin");
let user = {
  name: "Вася",
  [isAdmin]: true
};

console.log(user[isAdmin]);//true
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 3</h3>
                    <blockquote>
                        Свойство, объявленное через символ, не будет видно в for-in, Object.keys, Object.getOwnPropertyNames, также не будет добавлено
                        при использовании JSON.stringify
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
let user = {
  name: "Вася",
  age: 30,
  [Symbol.for("isAdmin")]: true
};

//в цикле for..in не будет символа
console.log(Object.keys(user));//["name", "age"]

//доступ к свойству через глобальный символ — работает
console.log(user[Symbol.for("isAdmin")]);//true
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Использование для private-членов</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var role = Symbol();
var user = {
    id: 1001,
    name: 'Administrator',
    [role]: 'admin'
};

var userRole = user[role];//admin - работает
var userRole1 = user.role;//undefined - не работает
var userRole2 = user['role'];//undefined - не работает
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Глобальные символы</h3>
                    <blockquote>
                        Глобальный реестр символов позволяет иметь общие глобальные символы, которые можно получить из реестра по имени. Используется
                        метод
                        <span class="highlight-blue">for</span>
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
//создание символа в реестре
let name = Symbol.for("name");

//символ уже есть, чтение из реестра
console.log(Symbol.for("name") == name);//true
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Встроенные символы</h2>
                    <small>
                        <table>
                            <tr>
                                <td>Symbol.iterator</td>
                                <td>возвращающий итератор для объекта</td>
                            </tr>
                            <tr>
                                <td>Symbol.match</td>
                                <td>сопоставление объекта со строкой (String.prototype.match)</td>
                            </tr>
                            <tr>
                                <td>Symbol.replace</td>
                                <td>заменяет совпавшие подстроки в строке (String.prototype.replace)</td>
                            </tr>
                            <tr>
                                <td>Symbol.search</td>
                                <td>возвращает индекс вхождения подстроки, соответствующей регулярному выражению (String.prototype.search)</td>
                            </tr>
                            <tr>
                                <td>Symbol.split</td>
                                <td>разбивает строку на части в местах, соответствующих регулярному выражению (String.prototype.split)</td>
                            </tr>
                            <tr>
                                <td>Symbol.for(key)</td>
                                <td>ищет существующие символы по заданному ключу и возвращает его, если он найден</td>
                            </tr>
                            <tr>
                                <td>Symbol.species</td>
                                <td>определяет конструктор для порожденных объектов</td>
                            </tr>
                        </table>
                    </small>
                </section>
                <section>
                    <h3>Symbol.iterator</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var str = "Hello";

let iterator = str[Symbol.iterator]();

while(true) {
  let result = iterator.next();
  if (result.done) break;
  console.log(result.value);//H e l l o
}
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
var iterableType = {}
iterableType[Symbol.iterator] = function* () {
    yield 1;
    yield 2;
    yield 3;
};

console.log([...iterableType]);//[1, 2, 3]
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Symbol.match</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
"/bar/".startsWith(/bar/);
//Uncaught TypeError: First argument to String.prototype.startsWith 
//must not be a regular expression
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
var reg = /foo/;
reg[Symbol.match] = false;

console.log("/foo/".startsWith(reg));//true
console.log("/baz/".endsWith(reg));//false
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Symbol.species</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Foo extends Array {
    static get [Symbol.species]() {
        return this;
    }
}

class Bar extends Array {
    static get [Symbol.species]() {
        return Array;
    }
}

//new Foo().map(function(){} -> Foo []
console.log(new Foo().map(function(){}) instanceof Foo);//true
console.log(new Bar().map(function(){}) instanceof Bar);//false
console.log(new Bar().map(function(){}) instanceof Array);//true
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Объекты и прототипы -->
            <section>
                <h1>Объекты и прототипы</h1>
            </section>
            <section>
                <section>
                    <h2>Короткое свойство</h2>
                    <blockquote>
                        При объявлении свойства объекта достаточно указать только его имя, а значение будет взято из переменной с аналогичным именем
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
let name = "Вася";
let isAdmin = true;

let user = {
  name,
  isAdmin
};

console.log(JSON.stringify(user));//{"name": "Вася", "isAdmin": true}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Вычисляемые свойства</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let propName = "firstName";
let user = {
    [propName]: "Вася"
};

console.log(user.firstName);//Вася
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример с функцией</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let a = "Зелёный ";
let b = "Крокодил";
let user = {
    [(a + b).toLowerCase()]: "Петя"
};

console.log( user["зелёный крокодил"] );//Петя
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Метод setPrototypeOf</h3>
                    <blockquote>
                        Метод устанавливает прототип (внутреннее свойство [[Prototype]]) указанного объекта в другой объект или null
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
Object.setPrototypeOf(obj, prototype);
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
var dict = Object.setPrototypeOf({}, null);
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
var person = {
    name: 'unknown'
};

var student = {
    group: 1
};

var p1 = Object.setPrototypeOf(student, person);
console.log(p1.group);//1
console.log(p1.name);//unknown
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Object.assign</h3>
                    <blockquote>
                        Метод используется для копирования значений всех собственных перечисляемых свойств из одного или более объектов в целевой
                        объект
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
Object.assign(target, src1, src2...)
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
var o1 = { a: 1 };
var o2 = { b: 2 };
var o3 = { c: 3 };

var obj = Object.assign(o1, o2, o3);
console.log(obj);//{ a: 1, b: 2, c: 3 }
console.log(o1); //{ a: 1, b: 2, c: 3 }
//изменился и целевой объект
                            </code>
                        </pre>
                </section>
                <section>
                    <h3>Object.is</h3>
                    <blockquote>
                        Метод определяет, являются ли два значения одинаковыми
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
var isSame = Object.is(value1, value2);
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
Object.is('foo', 'foo');   //true
Object.is(window, window); //true
Object.is('foo', 'bar');   //false
Object.is([], []);         //false

var test = { a: 1 };
Object.is(test, test);     //true
Object.is(null, null);     //true

//Специальные случаи
Object.is(0, -0);          //false
Object.is(-0, -0);         //true
Object.is(NaN, 0/0);       //true
Object.is(NaN, NaN);       //true
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Объявление метода</h3>
                    <p>Более короткий и удобный синтаксис</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
let name = "Вася";
let user = {
    name,
    //something: function()
    //{
    //console.log(this.name);
    //}
    something() {
        console.log(this.name);
    }
};

user.something();//Вася
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Классы -->
            <section>
                <h1>Классы</h1>
            </section>
            <section>
                <section>
                    <h2>Объявление класса</h2>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Название [extends Родитель]  {
    constructor
    методы
}
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Polygon {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Выражение класса</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
//безымянный
var Polygon = class {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
};

//именованный
var Polygon = class Polygon {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
};
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Создание объекта и прототип</h3>
                    <blockquote>
                        Constructor запускается при создании new Object, остальные методы записываются в Object.prototype
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
class User {
    constructor(name) {
        this.name = name;
    }
    sayHi() { console.log(this.name);}
}

let user = new User("Вася");
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
function User(name) {
    this.name = name;
}

User.prototype.sayHi = function() {
    console.log(this.name);
};
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Подъем (hoisting)</h3>
                    <blockquote>
                        Разница между объявлением функции (function declaration) и объявлением класса (class declaration) в том, что объявление функции
                        совершает подъём (hoisted), в то время как объявление класса — нет
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
var p = new Polygon();
class Polygon {}
//Uncaught ReferenceError: Polygon is not defined
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Статические методы</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    static distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt(dx*dx + dy*dy);
    }
}

const p1 = new Point(5, 5);
const p2 = new Point(10, 10);
console.log(Point.distance(p1, p2));//7.07....
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Геттеры, сеттеры</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
class User {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    get fullName() {
        return `${this.firstName} ${this.lastName}`;
    }
    
    set fullName(newValue) {
        [this.firstName, this.lastName] = newValue.split(' ');
    }
};

var user = new User('Maksim', 'Hladki');
console.log(user.fullName);//Maksim Hladki
user.fullName = "Ivan Ivanov";
console.log(user.fullName);//Ivan Ivanov
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Rectangle {
    constructor (width, height) {
        this._width  = width
        this._height = height
    }
    set width  (width)  { this._width = width}
    get width  ()       { return this._width}
    set height (height) { this._height = height}
    get height ()       { return this._height}
    get area   ()       { return this._width * this._height }
}

var test = new Rectangle(50, 20);
console.log(test.area);//1000
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Вычисляемые имена методов</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Foo() {
    myMethod() {}
}
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Foo() {
    ['my'+'Method']() {}
}
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
const m = 'myMethod';
class Foo() {
    [m]() {}
}
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Наследование -->
            <section>
                <section>
                    <h2>Наследование</h2>
                    <blockquote>
                        Только один конструктор, прототип, базовый класс!
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Child extends Parent {
    //TODO logic
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Point {
    constructor(x, y) {
        this.x = x; this.y = y;
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ')';
    }
}

class ColorPoint extends Point {
    constructor(color) {
        super(0, 0);
        this.color = color;
    }
    toString() {
        return super.toString() + ' in ' + this.color;
    }
}
var cPoint = new ColorPoint('red');
console.log(cPoint.toString());//(0, 0) in red
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Наследование статических методов</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Foo {
    static classMethod() {
        return 'hello';
    }
}

class Bar extends Foo {
    //TODO
}

console.log(Bar.classMethod());//hello
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Super</h2>
                    <blockquote>
                        Используется для вызова функций, принадлежащих родителю объекта
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
super([arguments]);//вызов родительского конструктора 
super.functionOnParent([arguments]);
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Вызов конструктора</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Polygon {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
}

class Square extends Polygon {
    constructor(length) {
        super(length, length);
    }
    get area() {
        return this.height * this.width;
    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Вызов метода</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Foo {
    static classMethod() {
        return 'hello';
    }
}

class Bar extends Foo {
    static classMethod() {
        return super.classMethod() + ', too';
    }
}

Bar.classMethod();//hello, too
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Mixins</h2>
                    <blockquote>
                        Абстрактные подклассы (mix-ins) — это шаблоны для классов. У класса может быть только один родительский класс, поэтому множественное
                        наследование невозможно. Функциональность должен предоставлять родительский класс
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
class B extends A, M {}//Uncaught SyntaxError: Unexpected token ,
//множественного наследования нет

const mixin = base => class extends base {
    /* свойства и методы */
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 1</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
class Person { ··· }

const Storage = Sup => class extends Sup {
    save(database) { ··· }
};

const Validation = Sup => class extends Sup {
    validate(schema) { ··· }
};

class Employee extends Storage(Validation(Person)) { ··· }
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let MyMixin = (superclass) => class extends superclass {  
    test() {
        console.log('test from MyMixin');
    }
};

class MyClass extends MyMixin(MyBaseClass) {  
    /* ... */
}

let c = new MyClass();  
c.test();//test from MyMixin
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Итераторы -->
            <section>
                <h1>Итераторы</h1>
            </section>
            <section>
                <section>
                    <h2>Всемогущественный for...of</h2>
                    <blockquote>
                        Выполняет цикл обхода итерируемых объектов, вызывая на каждом шаге итерации операторы для каждого значения из различных свойств
                        объекта
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
for (переменная of объект)
  оператор
                        </code>
                    </pre>
                    <ul>
                        <li>При итерациях используется значение, а не ключ</li>
                        <li>Можно использовать continue и break</li>
                        <li>Используется с Array, Map, Set, Object и т.д.</li>
                    </ul>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let arr = [ 3, 5, 7 ];
arr.foo = "hello";

for (let i in arr) {
   console.log(i);//"0", "1", "2", "foo"
}

for (let i of arr) {
   console.log(i);//"3", "5", "7"
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Различные типы данных</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
//Строки
let result = '';
for (let chr of 'this is string') {
  result += chr.trim();
}
console.log(result);//thisisstring

//Коллекции DOM элементов
let result = [];
for (let link of document.links) {
  result.push(link.href);
}
console.log(result);
//['http://google.com', 'https://yandex.by/', ...]
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Понятие итератора</h2>
                    <blockquote>
                        Объект является итератором, если он умеет обращаться к элементам коллекции по одному за раз, при этом отслеживая свое текущее
                        положение внутри этой последовательности
                    </blockquote>
                    <blockquote>
                        В JS итератор - это объект, который предоставляет метод next(), возвращающий следующий элемент последовательности. Этот метод
                        возвращает объект с двумя свойствами: done и value
                    </blockquote>
                </section>
                <section>
                    <h3>Спецификация</h3>
                    <pre>
                        <code class="hljs csharp" data-trim>
interface Iterable {
    [Symbol.iterator]() : Iterator;
}

interface Iterator {
    next() : IteratorResult;
}

interface IteratorResult {
    value: any;
    done: boolean;
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Итерируемые значения</h3>
                    <ul>
                        <li>Arrays</li>
                        <li>Strings</li>
                        <li>Maps</li>
                        <li>Sets</li>
                        <li>DOM data structures</li>
                    </ul>
                </section>
                <section>
                    <h3>Сфера применения</h3>
                    <img src="img/iterator.jpg" alt="">
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function makeIterator(array){
    var nextIndex = 0;
    
    return {
       next: function(){
           return nextIndex < array.length ?
               {value: array[nextIndex++], done: false} :
               {done: true};
       }
    }
}

var it = makeIterator(['hello', 'world']);
var first = it.next();
console.log(first.value);//'hello'
console.log(first.done);//false
var second = it.next();
console.log(second.value);//'world'
console.log(second.done);//false
console.log(it.next().done);//true
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Добавление к существующему объекту</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let range = {
  from: 1, to: 5
};

range[Symbol.iterator] = function() {
    let current = this.from;
    let last = this.to;
    return {
        next() {
            if (current <= last) {
                return {done: false, value: current++};
            } else {
                return {done: true};
            }
        }
    }
};
for (let num of range) 
    console.log(num)
//1 2 3 4 5
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Бесконечный итератор</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function infinity(){
    var index = 0;
    
    return {
       next: function(){
           return {
               value: index++, 
               done: false
            };
       }
    }
}

var it = infinity();
console.log(it.next().value);//0
console.log(it.next().value);//1
console.log(it.next().value);//2
//.....
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Встроенный итератор</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let str = "Hello";
let iterator = str[Symbol.iterator]();

while(true) {
  let result = iterator.next();
  if (result.done) break;
  console.log(result.value);//'H' 'e' 'l' 'l' 'o'
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Еще пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var someString = "hi";
var iterator = someString[Symbol.iterator]();
console.log(iterator + "");    //"[object String Iterator]"
 
console.log(iterator.next());  //{ value: "h", done: false }
console.log(iterator.next());  //{ value: "i", done: false }
console.log(iterator.next());  //{ value: undefined, done: true }
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Генераторы -->
            <section>
                <h1>Генераторы</h1>
            </section>
            <section>
                <section>
                    <h2>Понятие генератора</h2>
                    <blockquote>
                        Это функции с возможностью повторного входа после выхода. Их контекст исполнения (значения переменных) сохраняется при последующих
                        входах
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
function* gen(i){
    while(true){
        yield i++;
        yield* anotherGenerator(i);
    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Алгоритм работы</h3>
                    <ol>
                        <li>При вызове функции-генератора (тело исполняется не сразу) возвращается объект-итератор</li>
                        <li>При вызове метода next() итератора, тело генератора исполняется до первого встреченного оператора
                            yield
                        </li>
                        <li>Оператор yield определяет возвращаемое значение (либо делегирует возврат другому генератору при помощи
                            yield*)
                        </li>
                        <li>
                            Метод next() возвращает объект со свойством value (содержащим значение) и свойством done (указывает, что отдано последнее
                            значение)
                        </li>
                    </ol>
                </section>
                <section>
                    <h3>Простой пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function* idMaker(){
    var index = 0;
    while(true)
        yield index++;
}

var gen = idMaker();
console.log(gen.next().value);//0
console.log(gen.next().value);//1
console.log(gen.next().value);//2
//...
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Развернутый пример</h2>
                    <pre>
                        <code class="hljs javascript" data-trim>
function* generateSequence() {
    yield 1;
    yield 2;
    return 3;
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Шаг 1: замороженный вызов функции</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
//создаeт generator
let generator = generateSequence();
                        </code>
                    </pre>
                    <img src="img/generator-1.png" alt="">
                </section>
                <section>
                    <h3>Шаг 2: yield 1</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let one = generator.next();
console.log(JSON.stringify(one));//{value: 1, done: false}
                        </code>
                    </pre>
                    <img src="img/generator-2.png" alt="">
                </section>
                <section>
                    <h3>Шаг 3: yield 2</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let two = generator.next();
console.log(JSON.stringify(two));//{value: 2, done: false}
                        </code>
                    </pre>
                    <img src="img/generator-3.png" alt="">
                </section>
                <section>
                    <h3>Шаг 4: return 3</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let three = generator.next();
console.log(JSON.stringify(three));//{value: 3, done: true}
                        </code>
                    </pre>
                    <img src="img/generator-4.png" alt="">
                    <blockquote>
                        Новые вызовы generator.next() не имеют смысла. Они будут возвращать один и тот же объект
                    </blockquote>
                </section>
            </section>
            <section>
                <section>
                    <h2>Генератор – итератор</h2>
                    <pre>
                        <code class="hljs javascript" data-trim>
function* generateSequence() {
    yield 1;
    yield 2;
    return 3;
};

let generator = generateSequence();
for(let value of generator) {
    console.log(value);//1, затем 2
}

//Cтандартный перебор итератора 
//игнорирует value на последнем значении,
//при done: true
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Более сложный пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function *foo(x) {
    var y = 2 * (yield (x + 1));
    var z = yield (y / 3);
    return (x + y + z);
}

var it = foo( 5 );
console.log(it.next());     //{ value:6, done:false }
console.log(it.next(12));   //{ value:8, done:false }
console.log(it.next(13));   //{ value:42, done:true }
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример с числами Фибоначчи</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let fibonacci = {
    *[Symbol.iterator]() {
        let pre = 0, cur = 1;
        for (;;) {
            [ pre, cur ] = [ cur, pre + cur ];
            yield cur;
        }
    }
}

for (let n of fibonacci) {
    if (n > 100)
        break
    console.log(n)
}
//1 2 3 5 8 13 21 34 55 89
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Композиция генераторов</h3>
                    <pre>
                    <code class="hljs javascript" data-trim>
function* generateSequence(start, end) {
    for (let i = start; i <= end; i++) yield i;
}

function* generateAlphaNum() {
    //0..9
    yield* generateSequence(48, 57);
    //A..Z
    yield* generateSequence(65, 90);
    //a..z
    yield* generateSequence(97, 122);
}

let str = '';
for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);
}
console.log(str);
//0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Использование throw</h3>
                    <blockquote>
                        Внешний код может вернуть генератору в качестве результата yield любое значение, в том числе и ошибку
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
function* gen() {
    try {
        let result = yield "Сколько будет 2 + 2?";//(2)
    } catch(e) {
        console.log(e);//fatal error
    }
}

let generator = gen();
let question = generator.next().value;
console.log(question);//Сколько будет 2 + 2?
generator.throw(new Error("fatal error"));//(1)
//Error: fatal error
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Коллекции -->
            <section>
                <h1>Коллекции Set, Map, WeakSet и WeakMap</h1>
            </section>
            <section>
                <section>
                    <h2>Set</h2>
                    <blockquote>
                        Коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
new Set([iterable]);
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Основные свойства и методы</h3>
                    <table>
                        <tr>
                            <td>add(item)</td>
                            <td>добавляет в коллекцию item, возвращает set</td>
                        </tr>
                        <tr>
                            <td>delete(item)</td>
                            <td>удаляет item из коллекции, возвращает true, если он там был</td>
                        </tr>
                        <tr>
                            <td>has(item)</td>
                            <td>возвращает true, если item есть в коллекции</td>
                        </tr>
                        <tr>
                            <td>clear()</td>
                            <td>очищает set</td>
                        </tr>
                        <tr>
                            <td>keys()/values()</td>
                            <td>возвращает объект-итератор на все значения множества</td>
                        </tr>
                        <tr>
                            <td>size</td>
                            <td>возвращает количество элементов</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var mySet = new Set();
mySet.add(1);
mySet.add(5);
mySet.add("some text");

mySet.has(1);//true
mySet.has(3);//false
mySet.has(Math.sqrt(25));  //true
mySet.has("Some Text".toLowerCase());//true

mySet.size;//3
mySet.delete(5);//удаляет 5 из set
mySet.has(5);//false, 5 было удалено
mySet.size;//2, было удалено одно значение
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Обход множества</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var mySet = new Set();
mySet.add(1); mySet.add("some text");

for (let item of mySet) console.log(item);
//1, "some text" 
for (let item of mySet.keys()) console.log(item);
//1, "some text" 
for (let item of mySet.values()) console.log(item);
//1, "some text"

//преобразует set в Array
var myArr = [...mySet];//[1, "some text"]
//обратное преобразования 
var mySet2 = new Set([1,2,3,4]);

mySet2.forEach(function(value) {
  console.log(value);
});
//1 2 3 4
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Map</h2>
                    <blockquote>
                        Коллекция для хранения записей вида ключ-значение
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
new Map([iterable])
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Основные свойства и методы</h3>
                    <small>
                        <table>
                            <tr>
                                <td>size</td>
                                <td>возвращает общее количество записей</td>
                            </tr>
                            <tr>
                                <td>delete(key)</td>
                                <td>удаляет запись с ключом key, возвращает true, если такая запись была</td>
                            </tr>
                            <tr>
                                <td>clear()</td>
                                <td>очищает словарь</td>
                            </tr>
                            <tr>
                                <td>has(key)</td>
                                <td>возвращает true, если ключ есть в словаре</td>
                            </tr>
                            <tr>
                                <td>keys()</td>
                                <td>возвращает итерируемый объект для ключей</td>
                            </tr>
                            <tr>
                                <td>values()</td>
                                <td> возвращает итерируемый объект для значений</td>
                            </tr>
                            <tr>
                                <td>get(key)</td>
                                <td>возвращает значение элемента по ключу</td>
                            </tr>
                            <tr>
                                <td>set(key, value)</td>
                                <td>устанавливает новое значение для ключа</td>
                            </tr>
                        </table>
                    </small>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var myMap = new Map();
var keyObj = {},
    keyFunc = function () {},
    keyString = "a string";

myMap.set(keyString, "value associated with 'a string'");
myMap.set(keyObj, "value associated with keyObj");
myMap.set(keyFunc, "value associated with keyFunc");
myMap.size;//3

myMap.get(keyString);   //"value associated with 'a string'"
myMap.get(keyObj);      //"value associated with keyObj"
myMap.get(keyFunc);     //"value associated with keyFunc"
myMap.get("a string");  //"value associated with 'a string'"
                        //т.к. keyString === 'a string'

myMap.get({});          //undefined, т.к.keyObj !== {}
myMap.get(function(){});//undefined, т.к. keyFunc !== function (){}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Использование NaN в качестве ключей</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var myMap = new Map();
myMap.set(NaN, "not a number");
myMap.get(NaN);//"not a number"

var otherNaN = Number("foo");
myMap.get(otherNaN);//"not a number"
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Обход словаря</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var myMap = new Map();
myMap.set(0, "zero"); myMap.set(1, "one");

for (var [key, value] of myMap) {
  console.log(key + " = " + value);
}//"0 = zero" и "1 = one"

for (var key of myMap.keys()) {
  console.log(key);
}//"0" и "1"

for (var value of myMap.values()) {
  console.log(value);
}//"zero" и "one"

myMap.forEach(function(value, key, myMap) {
  console.log(key + " = " + value);
})//"0 = zero" и "1 = one"
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>WeakSet</h2>
                    <blockquote>
                        Коллекция, элементами которой могут быть только объекты. Ссылки на эти объекты являются слабыми. Каждый объект может быть
                        добавлен в WeakSet только один раз
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
new WeakSet([iterable]);
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>	
var ws = new WeakSet();
var obj = {};
var foo = {};

ws.add(window);
ws.add(obj);

ws.has(window);//true
ws.has(foo);//false, foo не добавлен в WeakSet
ws.delete(window);//удаляет window из WeakSet
ws.has(window);//false, window был удалён

ws.add('string');//Uncaught TypeError: Invalid value used in weak set
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>WeakMap</h2>
                    <blockquote>
                        Коллекция пар ключ-значение. В качестве ключей могут быть использованы только объекты, а значения могут быть произвольных
                        типов
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
new WeakMap([iterable])
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var wm1 = new WeakMap(),
    wm2 = new WeakMap();
var o1 = {},
    o2 = function(){},
    o3 = window,
    o4 = [1, 2, 3];

wm1.set(o1, 37);
wm1.set(o2, "azerty");
wm2.set(o1, o2);//значением может быть что угодно,
//включая объект или функцию
wm2.set(o3, undefined);
wm2.set(wm1, wm2);//ключами и значениями могут быть другие WeakMap

wm1.get(o2);//"azerty"
wm2.get(o2);//undefined, потому что нет значения для o2 в wm2
wm2.get(o3);//undefined, потому что это установленное значение
wm1.has(o2);//true
wm2.has(o2);//false
wm2.has(o3);//true (даже если значение равно 'undefined')
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Прокси -->
            <section>
                <h1>Прокси (Proxy)</h1>
            </section>
            <section>
                <section>
                    <h2>Понятие Proxy</h2>
                    <blockquote>
                        Особый объект, который перехватывает обращения к другому объекту и, при необходимости, модифицирует их
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
let proxy = new Proxy(target, handler)
                        </code>
                    </pre>
                    <ul>
                        <li>target – объект, обращения к которому надо перехватывать</li>
                        <li>handler – объект с функциями-перехватчиками для операций к target</li>
                    </ul>
                    <p class="highlight-blue">Если перехватчика нет – операция идет над target</p>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var target = {};
var superhero = new Proxy(target, {
   get: function(target, name, receiver) {
       console.log('get was called for: ', name);
       return target[name];
   }
});

superhero.power = 'Flight';
console.log(superhero.power);
//get was called for:  power
//Flight
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Виды перехватчиков</h2>
                    <small>
                        <table>
                            <tr>
                                <td>getPrototypeOf</td>
                                <td>перехватывает обращение к методу getPrototypeOf</td>
                            </tr>
                            <tr>
                                <td>setPrototypeOf</td>
                                <td>перехватывает обращение к методу setPrototypeOf</td>
                            </tr>
                            <tr>
                                <td>isExtensible</td>
                                <td>перехватывает обращение к методу isExtensible</td>
                            </tr>
                            <tr>
                                <td>preventExtensions</td>
                                <td>перехватывает обращение к методу preventExtensions</td>
                            </tr>
                            <tr>
                                <td>getOwnPropertyDescriptor</td>
                                <td>перехватывает обращение к методу getOwnPropertyDescriptor</td>
                            </tr>
                            <tr>
                                <td>defineProperty</td>
                                <td>перехватывает обращение к методу defineProperty</td>
                            </tr>
                            <tr>
                                <td>has</td>
                                <td>перехватывает проверку существования свойства</td>
                            </tr>
                            <tr>
                                <td>get</td>
                                <td>перехватывает чтение свойства</td>
                            </tr>
                            <tr>
                                <td>set</td>
                                <td>перехватывает запись свойства</td>
                            </tr>
                            <tr>
                                <td>deleteProperty</td>
                                <td> перехватывает удаление свойства оператором delete</td>
                            </tr>
                            <tr>
                                <td>ownKeys</td>
                                <td>перехватывает обращения к методу getOwnPropertyNames</td>
                            </tr>
                            <tr>
                                <td>apply</td>
                                <td>перехватывает вызовы target()</td>
                            </tr>
                            <tr>
                                <td>construct</td>
                                <td>перехватывает вызовы new target()</td>
                            </tr>
                        </table>
                    </small>
                </section>
                <section>
                    <h3>Перехватчики get/set</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
get(target, property, receiver)
                        </code>
                    </pre>
                    <ul>
                        <li>target – целевой объект</li>
                        <li>property – имя свойства</li>
                        <li>receiver – объект, к которому было применено присваивание. Обычно сам прокси, либо прототипно наследующий
                            от него</li>
                    </ul>
                    <pre>
                        <code class="hljs javascript" data-trim>
set(target, property, value, receiver)
                        </code>
                    </pre>
                    <ul>
                        <li>target – целевой объект</li>
                        <li>property – имя свойства</li>
                        <li>value – значение свойства</li>
                        <li>receiver – объект, к которому было применено присваивание</li>
                    </ul>
                </section>
                <section>
                    <h3>Пример get/set перехватчика</h3>
                    <pre>
                    <code class="hljs javascript" data-trim>
let user = {};

let proxy = new Proxy(user, {
    get(target, prop) {
        console.log(`Чтение ${prop}`);
        return target[prop];
    },

    set(target, prop, value) {
        console.log(`Запись ${prop} ${value}`);
        target[prop] = value;
        return true;
    }
});

proxy.firstName = "Maks";//Запись firstName Maks
proxy.firstName;//Чтение firstName
console.log(user.firstName);//Maks
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Перехватчик has</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let dictionary = {
  'Hello': 'Привет'
};

dictionary = new Proxy(dictionary, {
    has(target, phrase) {
        //target - исходный объект
        //phrase - имя проверяемого свойства
        return true;
    }
});

console.log("Any text" in dictionary);//true	
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Перехватчик deleteProperty</h3>
                    <pre>
                    <code class="hljs javascript" data-trim>
let dictionary = {
    'Hello': 'Привет'
};

let proxy = new Proxy(dictionary, {
    deleteProperty(target, phrase) {
        //target - исходный объект
        //phrase - имя удаляемого свойства
        return true; 
    }
});

//не удалит свойство
delete proxy['Hello'];
console.log("Hello" in dictionary);//true
//так как нет ловушки has, операция in сработает на исходном объекте
console.log("Hello" in proxy);//true
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Перехватчик ownKeys</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var target = {};

var proxy = new Proxy({}, {
    ownKeys: function(target) {
        console.log('ownKeys');
        return ['a', 'b', 'c'];
    }
});

console.log(Object.getOwnPropertyNames(proxy));//"ownKeys"
//["a", "b", "c"]
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Перехватчик apply</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function sum(a, b) {
    return a + b;
}

let proxy = new Proxy(sum, {
    //передаст вызов в target, предварительно сообщив о нём
    apply: function(target, thisArg, argumentsList) {
        //target – исходный объект
        //thisArgument – контекст this вызова
        //argumentsList – аргументы вызова в виде массива
        console.log(`Сумма: ${argumentsList}`);
        return target.apply(thisArg, argumentsList);
    }
});

console.log(proxy(1, 2));
//Сумма 1,2
//3
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Перехватчик construct</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
function User(name, surname) {
    this.name = name;
    this.surname = surname;
}

let UserProxy = new Proxy(User, {
    construct: function(target, argumentsList, newTarget) {
        //target – исходный объект.
        //argumentsList – аргументы вызова в виде массива
        //newTarget - конструктор, который был вызван
        console.log(newTarget);
        console.log(`Запуск new с аргументами: ${argumentsList}`);
        return new target(...argumentsList);
    }
});

let user = new UserProxy("Maksim", "Hladki");
//Запуск new с аргументами: Maksim,Hladki
                        </code>
                    </pre>
                </section>
            </section>
            <!-- обещание -->
            <section>
                <h1>Обещание</h1>
                <h3>(Promise)</h3>
            </section>
            <section>
                <section>
                    <h2>Понятие промиса</h2>
                    <blockquote>
                        Объект, используемый как заглушка для результата некоего отложенного (и асинхронного) вычисления
                    </blockquote>
                    <img src="img/promise.png" alt="" height="350">
                </section>
                <section>
                    <h3>Callback hell</h2>
                        <pre>
                            <code class="hljs javascript" data-trim>
getData(function(a){  
    getMoreData(a, function(b){
        getMoreData(b, function(c){ 
            getMoreData(c, function(d){ 
                getMoreData(d, function(e){ 
                    ...
                });
            });
        });
    });
});
                            </code>
                        </pre>
                </section>
                <section>
                    <h3>Синтаксис</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
new Promise(executor);
new Promise(function(resolve, reject) { ... });
                        </code>
                    </pre>
                    <ul>
                        <li>onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно»</li>
                        <li>onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой»</li>
                    </ul>
                </section>
                <section>
                    <h3>Алгоритм</h3>
                    <ol>
                        <li>Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его</li>
                        <li>Внешний код, получив promise, навешивает на него обработчики</li>
                        <li>
                            После завершения процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой).
                            При этом автоматически вызываются соответствующие обработчики во внешнем коде
                        </li>
                    </ol>
                </section>
                <section>
                    <h3>Навешивание обработчиков</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
promise.then(onFulfilled, onRejected)
//onFulfilled – функция, которая будет вызвана с результатом при resolve
//onRejected – функция, которая будет вызвана с ошибкой при reject
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
//onFulfilled сработает при успешном выполнении
promise.then(onFulfilled)
//onRejected сработает при ошибке
promise.then(null, onRejected)
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Метод then</h3>
                    <blockquote>
                        Метод возвращает Promise и принимает два аргумента, callback-функции для случаев выполнения и отказа соответственно
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
p.then(onFulfilled, onRejected);
p.then(
    function(value) {
        //выполнение
    }, 
    function(reason) {
        //отказ
    }
);
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Метод catch</h3>
                    <blockquote>
                        Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected)
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
promise.catch(onRejected);
promise.catch(function(reason) {
    //отказ
});
                        </code>
                    </pre>
                    <blockquote>
                        catch всегда возвращает положительный промис
                    </blockquote>
                </section>
                <section>
                    <h3>throw в промисах</h3>
                    <blockquote>
                        Синхронный throw – то же самое, что reject
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
let p = new Promise((resolve, reject) => {
    //то же что reject(new Error("Ошибка"))
    throw new Error("Ошибка");
});

p.catch(console.log);//Ошибка
                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Эмуляция асинхронности</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("result");
    }, 1000);
});

promise.then(
    result => {
        console.log("Fulfilled: " + result);
        //result - аргумент resolve
    },
    error => {
        console.log("Rejected: " + error);
        //error - аргумент reject
    }
);

//Fulfilled: result
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Еще пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var promise = new Promise(function(resolve, reject) {
    console.log('in Promise constructor function');
    setTimeout(function() {
        console.log('in setTimeout callback');
        resolve('foo');
    }, 100);
});

console.log('created promise');
promise.then(function(result) {
    console.log('promise returned: ' + result);
});

console.log('hooked promise.then()');
//in Promise constructor function
//created promise
//hooked promise.then()
//in setTimeout callback
//promise returned: foo
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Promise после reject/resolve – неизменны</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let promise = new Promise((resolve, reject) => {
  // через 1 секунду готов результат: result
  setTimeout(() => resolve("result"), 1000);

  // через 2 секунды — reject с ошибкой, он будет проигнорирован
  setTimeout(() => reject(new Error("ignored")), 2000);
});

promise.then(
    result => console.log("Fulfilled: " + result),//сработает
    error => console.log("Rejected: " + error)//не сработает
);
//Fulfilled: result
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Промисификация</h3>
                    <blockquote>
                        Процесс, при котором из асинхронной функции делают обертку, возвращающую promise
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
function httpGet(url) {
    return new Promise(function(resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onload = function() {
        if (this.status == 200) {
            resolve(this.response);
        } else {
            var error = new Error(this.statusText);
            error.code = this.status;
            reject(error);
        }
    };
    xhr.onerror = function() {
        reject(new Error("Network Error"));
    };
    xhr.send();
  });
}
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Методы в промисах -->
            <section>
                <section>
                    <h2>Метод Promise.resolve</h2>
                    <blockquote>
                        Метод возвращает Promise, выполненный с переданным значением. Если переданное значение является thenable (имеет метод then),
                        возвращаемое обещание будет следовать thenable - объекту, принимая свое состояние; в ином случае
                        возвращаемое обещание будет выполнено с переданным значением
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
Promise.resolve(value);
Promise.resolve(promise);
Promise.resolve(thenable);
                            </code>
                        </pre>
                </section>
                <section>
                    <h3>Пример 1</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
Promise.resolve("Success").then(
    function(value) {
        console.log(value);//"Success"
    }, 
    function(value) {
        //не будет вызванна
    }
);
                            </code>
                        </pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var p = Promise.resolve([1,2,3]);
p.then(function(v) {
    console.log(v[0]);//1
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 3</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var original = Promise.resolve(true);
console.log(original);//Promise {resolved: true}

var cast = Promise.resolve(original);

cast.then(function(v) {
    console.log(v);//true
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Метод Promise.reject</h2>
                    <blockquote>
                        Метод возвращает объект Promise, который был отклонен по указанной причине
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
Promise.reject(reason);
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
Promise.reject("Проверка статического reject").then(
    function(reason) {
        //не вызывается
    }, 
    function(reason) {
        console.log(reason);//"Проверка статического reject"
    }
);
                            </code>
                        </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
Promise.reject(new Error("Ошибка")).then(
    function(error) {
        //не вызывается
    }, 
    function(error) {
        console.log(error);//Ошибка
    }
);
                            </code>
                        </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Метод Promise.all</h2>
                    <blockquote>
                        Возвращает обещание, которое выполнится тогда, когда будут выполнены все обещания, переданные в виде перечисляемого аргумента,
                        или отклонено любое из переданных обещаний
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
Promise.all(iterable);
//iterable - перечисляемый объект, например, массив (Array)
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 1</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var p1 = Promise.resolve(3);
var p2 = 1337;
var p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, "foo");
}); 

Promise.all([p1, p2, p3]).then(values => { 
  console.log(values); 
});
//[3, 1337, "foo"] 
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var p1 = Promise.resolve(3);
var p2 = Promise.reject("Promise Reject");
var p3 = new Promise((resolve, reject) => {
    setTimeout(resolve, 100, "foo");
}); 
    
Promise.all([p1, p2, p3]).then(
    values => console.log(values),
    error => console.log(error)
);
//Promise Reject
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 3</h3>
                    <pre>
                    <code class="hljs javascript" data-trim>
var p1 = new Promise((resolve, reject) => { 
  setTimeout(resolve, 1000, "one"); 
});

var p2 = new Promise((resolve, reject) => { 
  setTimeout(resolve, 2000, "two"); 
});

var p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 3000, "three");
});

var p4 = new Promise((resolve, reject) => {
  reject("reject");//Это обещание прервет Promise.all
});

Promise.all([p1, p2, p3, p4]).then(
    value => console.log(value), 
    reason => console.log(reason)
);//"reject"
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 4</h3>
                    <pre>
                    <code class="hljs javascript" data-trim>
function fetchAsync (url, timeout, onData, onError) {
    //TODO
}

let fetchPromised = (url, timeout) => {
    return new Promise((resolve, reject) => {
        fetchAsync(url, timeout, resolve, reject)
    });
}

Promise.all([
    fetchPromised("http://test/method1", 500),
    fetchPromised("http://test/method2", 500),
    fetchPromised("http://test/method3", 500)
]).then((data) => {
    let [foo, bar, baz] = data
    console.log(`success: foo=${foo} bar=${bar} baz=${baz}`)
}, (err) => {
    console.log(`error: ${err}`)
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Метод Promise.race</h2>
                    <blockquote>
                        Метод возвращает выполненое или отклоненное обещание, в зависимости от того, с каким результатом завершится первое из переданных
                        обещаний, со значением или причиной отклонения этого обещания
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
Promise.race(iterable);
//iterable - итерируемый объект, такой как (Array)
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 1</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var p1 = new Promise(function(resolve, reject) { 
    setTimeout(resolve, 500, "один"); 
});

var p2 = new Promise(function(resolve, reject) { 
    setTimeout(resolve, 100, "два"); 
});

Promise.race([p1, p2]).then(function(value) {
    console.log(value);//"два"
    //Оба вернули resolve, однако p2 вернул результат первым
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var p1 = Promise.resolve(3);
var p2 = Promise.reject("Promise Reject");
var p3 = new Promise((resolve, reject) => {
    setTimeout(resolve, 100, "foo");
}); 
        
Promise.race([p1, p2, p3]).then(
    values => console.log(values),
    error => console.log(error)
);
//3
                         </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 3</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var p3 = new Promise(function(resolve, reject) { 
    setTimeout(resolve, 100, "три");
});

var p4 = new Promise(function(resolve, reject) { 
    setTimeout(reject, 500, "четыре"); 
});

Promise.race([p3, p4]).then(function(value) {
    console.log(value);//"три"
    //p3 быстрее, поэтому выведется значение его resolve
}, function(reason) {
    //Не вызывается
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 4</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var p5 = new Promise(function(resolve, reject) { 
    setTimeout(resolve, 500, "пять"); 
});

var p6 = new Promise(function(resolve, reject) { 
    setTimeout(reject, 100, "шесть");
});

Promise.race([p5, p6]).then(
    function(value) {
        //Не вызывается
    }, 
    function(reason) {
        console.log(reason);//"шесть"
        //p6 быстрее, выводится его rejects
    }
);
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Цепочки промисов</h2>
                    <pre>
                        <code class="hljs javascript" data-trim>
something(...)
    .then(...)
    .then(...)
    .then(...);
                        </code>
                    </pre>
                    <blockquote>
                        Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат
                    </blockquote>
                </section>
                <section>
                    <h3>Пример 1</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
Promise.resolve("Success")  
    .then(x =>  { console.log("THEN1", x);  })
    .catch(x => { console.log("CATCH1", x); })
    .then(x =>  { console.log("THEN2", x);  })
    .catch(x => { console.log("CATCH2", x); });
//THEN1 Success
//THEN2 undefined
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
Promise.reject("Fail")  
    .then(x =>  { console.log("THEN1", x);  })
    .catch(x => { console.log("CATCH1", x); })
    .then(x =>  { console.log("THEN2", x);  })
    .catch(x => { console.log("CATCH2", x); });
//CATCH1 Fail
//THEN2 undefined
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 3</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
Promise.reject("Fail")  
    .catch(x => {
        console.log("CATCH1", x);
        return Promise.reject("B");
    })
    .then(x =>  { console.log("THEN1", x);  })
    .catch(x => { console.log("CATCH2", x); })
    .then(x =>  { console.log("THEN2", x);  });
//CATCH1 Fail
//CATCH2 B
//THEN2 undefined
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 4</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
//get - магическая функция получения данных
get(url)
    .then(function(response) {
        response = JSON.parse(response);
        var secondURL = response.data.url
        return get( secondURL ); //возвращаем новый промис
    })
    .then(function(response) {
        response = JSON.parse(response);
        var thirdURL = response.data.url
        return get( thirdURL ); // возвращаем новый промис
    })
    .catch(function(err) {
        handleError(err);
    });
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h3>Fetch API</h3>
                    <blockquote>
                        Метод fetch: замена XMLHttpRequest
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
let promise = fetch(url[, options]);
//url – URL, на который сделать запрос,
//options – необязательный объект с настройками запроса.
                            </code>
                        </pre>
                </section>
                <section>
                    <h3>Свойства options</h3>
                    <small>
                        <table>
                            <tr>
                                <td>method</td>
                                <td>метод запроса</td>
                            </tr>
                            <tr>
                                <td>headers</td>
                                <td>заголовки запроса (объект)</td>
                            </tr>
                            <tr>
                                <td>body </td>
                                <td>тело запроса: arrayBuffer, blob, formData, json или text</td>
                            </tr>
                            <tr>
                                <td>mode</td>
                                <td>указывает, в каком режиме кросс-доменности предполагается делать запрос: same-origin, no-cors,
                                    cors
                                </td>
                            </tr>
                            <tr>
                                <td>credentials</td>
                                <td>указывает, пересылать ли куки и заголовки авторизации вместе с запросом: omit, same-origin,
                                    include
                                </td>
                            </tr>
                            <tr>
                                <td>cache</td>
                                <td>указывает, как кешировать запрос: default, no-store, reload, no-cache, force-cache, only-if-cached</td>
                            </tr>
                            <tr>
                                <td>redirect</td>
                                <td>«follow» для обычного поведения при коде 30x (следовать редиректу) или «error» для интерпретации
                                    редиректа как ошибки</td>
                            </tr>
                        </table>
                    </small>
                </section>
                <section>
                    <h3>Пример 1</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
fetch('/article/fetch/user.json')
    .then(function(response) {
        console.log(response.headers.get('Content-Type')); 
        //application/json; charset=utf-8
        console.log(response.status);//200
        return response.json();
    })
    .then(function(user) {
        console.log(user.name);//Maks
    })
    .catch(console.log);
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var myImage = document.querySelector('img');
fetch('flowers.jpg')
    .then(function(response) {
        return response.blob();
    })
    .then(function(myBlob) {
        var objectURL = URL.createObjectURL(myBlob);
        myImage.src = objectURL;
    });
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 3</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var myHeaders = new Headers();
var myInit = { 
    method: 'GET',
    headers: myHeaders,
    mode: 'cors',
    cache: 'default' 
};

fetch('flowers.jpg',myInit)
    .then(function(response) {
        return response.blob();
    })
    .then(function(myBlob) {
        var objectURL = URL.createObjectURL(myBlob);
        myImage.src = objectURL;
    });
                            </code>
                        </pre>
                </section>
                <section>
                    <h3>Пример 4</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var form = new FormData(document.getElementById('login-form'));
fetch("/login", {
    method: "POST",
    body: form
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 5</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var request = new Request("/users", {
    method: 'POST', 
    mode: 'cors', 
    headers: new Headers({
        'Content-Type': 'text/plain'
    }),
    body: data
});

fetch(request).then(function() { 
    //обработка ответа
});
                        </code>
                    </pre>
                </section>
            </section>
            <!-- модули -->
            <section>
                <h1>Модули</h1>
                <h3>(modules)</h3>
            </section>
            <section>
                <h2>Модули в ES5</h2>
                <p>CommonJS (CJS)</p>
                <ul>
                    <li>компактный синтаксис</li>
                    <li>предназначен для синхронной загрузки</li>
                    <li>преимущественно используется на стороне сервера</li>
                </ul>
                <p>Asynchronous Module Definition (AMD)</p>
                <ul>
                    <li>синтаксис немного сложнее, что позволяет AMD работать без eval() или этапа компиляции</li>
                    <li>предназначен для асинхронной загрузки</li>
                    <li>преимущественно используется на стороне клиента</li>
                </ul>
            </section>
            <section>
                <section>
                    <h2>Модули в ES6</h2>
                    <blockquote>
                        Модулем считается файл с кодом. В этом файле ключевым словом export помечаются переменные и функции, которые могут быть использованы
                        снаружи. Другие модули могут подключать их через вызов import
                    </blockquote>
                    <p>
                        Целью модулей es6 было создание формата, удобного как для пользователей CJS, так и для пользователей AMD. В связи с этим
                        они имеют такой же компактный синтаксис, как и модули CJS. С другой стороны, они не такие динамичные
                        как и AMD
                    </p>
                </section>
                <section>
                    <h2>Особенности</h2>
                    <ul>
                        <li>на этапе компиляции возникнет ошибка, если попытаться импортировать что-то, что не было предварительно
                            экспортировано
                        </li>
                        <li>можно легко осуществить асинхронную загрузку модулей</li>
                        <li>декларативный синтаксис (для импорта и экспорта)</li>
                        <li>программная загрузка (чтобы задать конфигурацию загрузки модулей и для условной загрузки модулей)</li>
                    </ul>
                </section>
                <section>
                    <h3>Пример</h3>
                    <p>
                        При запуске в chrome видем ошибку
                        <span class="highlight-red">Uncaught SyntaxError: Unexpected token import</span>. Слабая поддержка браузеров. Необходимо использовать
                        babel.js либо аналогичный инструмент
                    </p>
                    <pre>
                        <code class="hljs javascript" data-trim>
lib/math.js
index.js
other.js
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
// lib/math.js
export function sum (x, y) { return x + y; }
export var pi = 3.141593;

// index.js
import * as math from "lib/math";
console.log("2π = " + math.sum(math.pi, math.pi));

// other.js
import { sum, pi } from "lib/math";
console.log("2π = " + sum(pi, pi));
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Export</h2>
                    <pre>
                        <code class="hljs javascript" data-trim>
export { name1, name2, …, nameN };
export { variable1 as name1, variable2 as name2, …, nameN };

export let name1, name2, …, nameN;//или var, const
export let name1 = …, name2 = …, …, nameN;//или var, const

export default выражение;
export default function (…) { … } //или class, function*
export default function name1(…) { … } //или class, function*

export { name1 as default, … };
export * from …;
export { name1, name2, …, nameN } from …;
export { import1 as name1, import2 as name2, …, nameN } from …;
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Export переменных</h3>
                    <ul>
                        <li>возможно перед объявлением переменных, функций и классов</li>
                        <li>возможно отдельно, при этом в фигурных скобках указывается то, что именно экспортируется</li>
                    </ul>
                    <pre>
                        <code class="hljs javascript" data-trim>
export let one = 1;
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
let two = 2;
export {two};
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
export {one, two};
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Ключевое слово AS</h3>
                    <blockquote>
                        При AS можно указать, что переменная one будет доступна снаружи (экспортирована) под другим именем
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
export {one as once, two as twice};
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Export функций и классов</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
export class User {
    constructor(name) {
        this.name = name;
    }
};

export function sayHi() {
    console.log("Hello!");
};
//export {User, sayHi}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Экспорт по умолчанию</h3>
                    <blockquote>
                        Иногда модуль экспортирует только одно значение (класс). В таком случае удобно определить это значение как экспортируемое
                        по умолчанию
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
//user.js
export default class User {
    constructor(name) {
        this.name = name;
    }
};

//login.js:
import User from './user';
new User("Петя");
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Import</h2>
                    <blockquote>
                        Другие модули могут подключать экспортированные значения при помощи ключевого слова import
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
import defaultMember from "module-name"; 
import * as name from "module-name"; 

import { member } from "module-name"; 
import { member as alias } from "module-name"; 
import { member1 , member2 } from "module-name"; 
import { member1 , member2 as alias2 , [...] } from "module-name";

import defaultMember, { member [ , [...] ] } from "module-name"; 
import defaultMember, * as name from "module-name"; 
import "module-name";
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
//nums.js:
export let one = 1;
export let two = 2;
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
import {one, two} from "./nums";
console.log(`${one} and ${two}`);//1 and 2
                        </code>
                    </pre>
                    <pre>
                        <code class="hljs javascript" data-trim>
//использование as
//импорт one под именем item1, а two – под именем item2
import {one as item1, two as item2} from "./nums";
console.log(`${item1} and ${item2}`);//1 and 2
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Импорт всех значений в виде объекта</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
import * as numbers from "./nums";
//теперь экспортированные переменные - свойства numbers
console.log(`${numbers.one} and ${numbers.two}`);//1 and 2
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Встроенные модули</h3>
                    <p>ES5</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
&lt;script&gt;
    (function () {  //начало самовызывающейся функции
        var tmp = 100;  //не станет глобальной
    }());  //конец самовызывающейся функции
&lt;/script&gt;
                        </code>
                    </pre>
                    <p>ES6</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
&lt;script&gt;
    module {  //анонимный внутренний модуль
        let tmp = 100;  //не станет глобальной
    }
&lt;/script&gt;
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Импорт модулей и загрузка скриптов</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
System.import(['module1', 'module2'], 
   function (module1, module2) { //успешное выполнение … }, 
   function (err) { //ошибка … } );
                        </code>
                    </pre>
                </section>
            </section>
            <!-- Другое -->
            <section>
                <h1>Другие особенности</h1>
            </section>
            <section>
                <h2>Поддержка bin/oct литералов</h2>
                <p>ES5</p>
                <pre>
                    <code class="hljs javascript" data-trim>
parseInt("111110111", 2) === 503;
parseInt("767", 8) === 503;
0767 === 503; 
                    </code>
                </pre>
                <p>ES6</p>
                <pre>
                    <code class="hljs javascript" data-trim>
0b111110111 === 503
0o767 === 503
                    </code>
                </pre>
            </section>
            <section>
                <section>
                    <h2>Работа с бинарными данными</h2>
                    <img src="img/arraybuffer.jpg" alt="">
                </section>
                <section>
                    <h3>ArrayBuffer</h3>
                    <blockquote>
                        Используется для работы с бинарными данными. Представляет собой ссылку на поток двоичных данных, однако работать с ними напрямую
                        возможности не дает. Вместо этого, необходимо создать типизированный массив или объект DataView
                    </blockquote>
                    <pre>
                        <code class="hljs javascript" data-trim>
new ArrayBuffer(length)//длина буфера в байтах
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var buffer = new ArrayBuffer(12);
var dataView = new DataView(buffer);
var int8View = new Int8Array(buffer);

dataView.setInt32(0, 0x1234ABCD);

console.log(dataView.getInt32(0).toString(16));//1234abcd
console.log(dataView.getInt8(0).toString(16));//12
console.log(int8View[0].toString(16));//12
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Типизированный массив</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
new TypedArray(length);
new TypedArray(typedArray);
new TypedArray(object);
new TypedArray(buffer [, byteOffset [, length]]);

где TypedArray() это одно из следующих значений:
Int8Array(), 
Uint8Array(), 
Uint8ClampedArray(), 
Int16Array(), 
Uint16Array(), 
Int32Array(), 
Uint32Array(), 
Float32Array(), 
Float64Array()
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 1</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let typedArray = new Uint8Array([0,1,2]);
console.log(typedArray.length);//3
typedArray[0] = 5;

let normalArray = [...typedArray];//[5,1,2]

console.log(ArrayBuffer.isView(new Int32Array()));//true
console.log(ArrayBuffer.isView(typedArray));//true
console.log(ArrayBuffer.isView(normalArray));//false

let dataView = new DataView(typedArray.buffer);
console.log(dataView.getUint8(0));//5
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
var buffer = new ArrayBuffer(12);

var x = new DataView(buffer, 0);
x.setInt8(0, 22);
x.setFloat32(1, Math.PI);

console.log(x.getInt8(0));  //22
console.log(x.getFloat32(1));//3.1415927410125732
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 3</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let ui8 = Uint8Array.of(0,1,2);
for (let byte of ui8) {
    console.log(byte);
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 4</h3>
                    <pre>
                    <code class="hljs javascript" data-trim>
function ab2str(buf) {
    return String.fromCharCode.apply(null, new Uint16Array(buf));
}

function str2ab(str) {
    var buf = new ArrayBuffer(str.length*2);//2 bytes for each char
    var bufView = new Uint16Array(buf);
    for (var i=0, strLen=str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 5</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let fileInput = document.getElementById('fileInput');
let file = fileInput.files[0];
let reader = new FileReader();
reader.readAsArrayBuffer(file);
reader.onload = function () {
    let arrayBuffer = reader.result;
    //···
};
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 6</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let xhr = new XMLHttpRequest();
xhr.open('GET', someUrl);
xhr.responseType = 'arraybuffer';
    
xhr.onload = function () {
    let arrayBuffer = xhr.response;
    //···
};
    
xhr.send();
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 7</h3>
                    <pre>
                        <code class="hljs javascript" data-trim>
let socket = new WebSocket('ws://127.0.0.1:8081');
socket.binaryType = 'arraybuffer';
    
socket.addEventListener('open', function (event) {
    let typedArray = new Uint8Array(4);
    socket.send(typedArray.buffer);
});
    
socket.addEventListener('message', function (event) {
    let arrayBuffer = event.data;
    //...
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Новый метод: find</h2>
                    <p>ES5</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
[ 1, 3, 4, 2 ].filter(function (x) { return x > 3; })[0];//4
                        </code>
                    </pre>
                    <p>ES6</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
[ 1, 3, 4, 2 ].find(x => x > 3);//4	
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Новые методы: isNaN/isFinite</h2>
                    <p>ES5</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
var isNaN = function (n) {return n !== n;};
var isFinite = function (v) {
    return (typeof v === "number" 
	&& !isNaN(v) && v !== Infinity && v !== -Infinity);
};
isNaN(42);//false;
isNaN(NaN);//true;
isFinite(Infinity);//false;
                        </code>
                    </pre>
                    <p>ES6</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
Number.isNaN(42);//false
Number.isNaN(NaN) //true
Number.isFinite(-Infinity);//false
Number.isFinite(NaN);//false
Number.isFinite(123);//true
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Новый метод: isSafeInteger</h2>
                    <p>ES5</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
function isSafeInteger (n) {
    return (
           typeof n === 'number'
        && Math.round(n) === n
        && -(Math.pow(2, 53) - 1) <= n
        && n <= (Math.pow(2, 53) - 1)
    );
}

isSafeInteger(42) === true;
isSafeInteger(9007199254740992) === false;
                        </code>
                    </pre>
                    <p>ES6</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
Number.isSafeInteger(42) === true
Number.isSafeInteger(9007199254740992) === false
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Новое свойство: EPSILON</h2>
                    <p>ES5</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
console.log(0.1 + 0.2 === 0.3);//false
console.log(Math.abs((0.1 + 0.2)-0.3) < 2.220446049250313e-16);//true
                        </code>
                    </pre>
                    <p>ES6</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
console.log(0.1 + 0.2 === 0.3);//false
console.log(Math.abs((0.1 + 0.2) - 0.3) < Number.EPSILON);//true
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Новый метод: trunc</h2>
                    <p>ES5</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
function mathTrunc (x) {
    return (x < 0 ? Math.ceil(x) : Math.floor(x));
}

console.log(mathTrunc(42.7));//42
console.log(mathTrunc( 0.1));//0
console.log(mathTrunc(-0.1));//-0
                        </code>
                    </pre>
                    <p>ES6</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
console.log(Math.trunc(42.7));//42
console.log(Math.trunc( 0.1));//0
console.log(Math.trunc(-0.1));//-0
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Новый метод: sign</h2>
                    <p>ES5</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
function mathSign (x) {
    return ((x === 0 || isNaN(x)) ? x : (x > 0 ? 1 : -1));
}

console.log(mathSign(7));//1
console.log(mathSign(0));//0
console.log(mathSign(-0));//-0
console.log(mathSign(-7));//-1
console.log(mathSign(NaN));//NaN
                        </code>
                    </pre>
                    <p>ES6</p>
                    <pre>
                        <code class="hljs javascript" data-trim>
console.log(Math.sign(7));//1
console.log(Math.sign(0));//0
console.log(Math.sign(-0));//-0
console.log(Math.sign(-7));//-1
console.log(Math.sign(NaN));//NaN
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <h2>Локализация</h2>
                <pre>
                    <code class="hljs javascript" data-trim>
var l10nEN = new Intl.NumberFormat("en-US");
var l10nDE = new Intl.NumberFormat("de-DE");
l10nEN.format(1234567.89);//1,234,567.89
l10nDE.format(1234567.89);//1.234.567,89

var l10nUSD = new Intl.NumberFormat("en-US", 
    { style: "currency", currency: "USD" });
var l10nEUR = new Intl.NumberFormat("de-DE", 
    { style: "currency", currency: "EUR" });

l10nUSD.format(100200300.40);//$100,200,300.40
l10nEUR.format(100200300.40);//100.200.300,40 €

var l10nEN = new Intl.DateTimeFormat("en-US");
var l10nDE = new Intl.DateTimeFormat("de-DE");
l10nEN.format(new Date("2015-01-02"));//1/2/2015
l10nDE.format(new Date("2015-01-02"));//2.1.2015
                    </code>
                </pre>
            </section>
            <section>
                <h2 class="header-hide">Спасибо за внимание</h2>
                <img src="img/thanks.png" alt="" height="600">
            </section>
        </div>
    </div>
    <aside id="presentable-icon" class="revealjs">
        <a title="Содержание лекции" href="#/0/1">
            <i class="fa fa-list-ul fa-2x"></i>
        </a>
    </aside>
    <script src="../../js/bundle.min.js"></script>
</body>

</html>