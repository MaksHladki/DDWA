<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>ECMAScript 5</title>
	<meta name="description" content="ECMAScript 5">
	<meta name="keywords" content="ECMAScript 5, строгий режим, наследование, ООП, события">
	<meta name="author" content="Maks Hladki">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section>
				<section>
					<h1>Стандарт ECMAScript 5</h1>
					<h3>Разработка динамичесих веб приложений</h3>
					<p>
						<small>Гладкий Максим Валерьевич / <a href="https://github.com/MaksHladki/DDWA/">github:MaksHladki</a></small>
					</p>
				</section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
			<section>
				<h1>Строгий режим</h1>
				<h3>(strict mode)</h3>
			</section>
			<section>
				<h2>Особенности</h2>
				<ul>
					<li>Более строгий вариант JavaScript</li>
					<li>Семантика, отличающаяся от обычно принятой</li>
					<li>Старые версии браузеров игнорируют строгий режим (<span class="highlight-blue">IE 9-</span>)</li>
					<li>Отменить действие use strict нельзя</li>
					<li>Применяется ко всему скрипту или к отдельным функциям</li>
					<li>Скрипт в строгом режиме + скрипт в обычном = скрипт в строгом режиме</li>
				</ul>
			</section>
			<section>
				<h2>Строгий режим для всего скрипта</h2>
				<pre>
					<code class="hljs" data-trim contenteditable>
						"use strict";
myFunction();

function myFunction() {
    y = 3.14; 
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Строгий режим для функции</h2>
				<pre>
					<code class="hljs" data-trim contenteditable>      
var PI = 3.14;
myFunction();

function myFunction() {
   "use strict";
    var y = 3.14; 
}
					</code>
				</pre>
			</section>
			<section>
				<section>
					<h2>Правила игры</h2>
					<img data-src="img/batman-usescript.jpg">
				</section>
				<section>
					<h3>Дублирование ключей в объекте</h3>
					<pre>
						<code class="hljs" data-trim>
var colors = {
	red: '#FF0000',
	green: '#00FF00',
	blue: '#0000FF',
	red: '#FF0000'
};
//Ex: An object literal cannot have multiple 
//properties with the same name in strict mode.
						</code>
					</pre>
				</section>
				<section>
					<h3>Объявление переменных без var</h3>
					<pre>
						<code class="hljs" data-trim>
PI = 3.14;
//EX: PI is not defined
						</code>
					</pre>
				</section>
				<section>
					<h3>Дублирование аргументов функции</h3>
					<pre>
						<code class="hljs" data-trim>
function log(arg, arg) {
    console.log(arguments);
}
    
log(1, 2, 4);
//EX: Duplicate parameter name not allowed in this context
						</code>
					</pre>
				</section>
				<section>
					<h3>Удаление "стандартных" свойств</h3>
					<pre>
						<code class="hljs" data-trim>
delete Object.prototype; 
//Ex: Cannot delete property 'prototype' of function Object() 
						</code>
					</pre>
				</section>
				<section>
					<h3>Eval не добавляет новых переменных в окружающий контекст</h3>
					<pre>
						<code class="hljs" data-trim>
							var x = 17;
var evalX = eval("var x = 42;x");
console.log(x); //17
console.log(evalX); //42
						</code>
					</pre>
				</section>
				<section>
					<h3>Нельзя использовать with</h3>
					<pre>
						<code class="hljs" data-trim>
var x = 17;
with (obj)
{
  x;
}
//Ex: syntax error
						</code>
					</pre>
				</section>
			</section>
			<!--Область видимости функций и замыкания-->
			<section>
				<h1>Область видимости функций и замыкания</h1>
			</section>
			<section>
				<section>
					<h2>Глобальный объект window</h2>
					<blockquote>
						В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «
						<span class="highlight-blue">глобальный объект
							</span>» (global object).
					</blockquote>
					<p class="text">
						В браузере этот объект доступен под именем <span class="highlight-blue">window</span>.
					</p>
					<p class="text">
						Объект window одновременно является глобальным объектом и содержит ряд свойств и методов для работы с окном браузера.
					</p>
				</section>
				<section>
					<h3>Oбъект window: свойства и методы</h3>
					<img src="img/window.png" />
				</section>
				<section>
					<h3>Oбъект window: свойства и методы</h3>
					<img src="img/window_2.png" />
				</section>
				<section>
					<h3>Oбъект window: чтение/запись</h3>
					<pre>
						<code class="hljs" data-trim>
var browser = 'Chrome';
console.log(window.browser); //Chrome

window.browser = 'Opera';
console.log(window.browser); //Opera
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Порядок выполнения JS-скрипта</h2>
					<ol>
						<li class="fragment">Инициализация, подготовка к запуску</li>
						<li class="fragment">Выполнение</li>
					</ol>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs" data-trim>
// window = { f: function, log: undefined, browser: undefined }

var browser = 'Chrome';
// window = { f: function, log: undefined, browser: 'Chrome' }

var log = function (msg) {
        console.log(msg);
}
// window = { f: function, log: function, browser: 'Chrome' }

function f() {}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Свойства глобальной области видимости</h2>
					<ul>
						<li>Конструкции for, if... не влияют на видимость</li>
						<li>Повторное oбъявление переменных</li>
						<li>Особенности при работе с window в IE8-</li>
					</ul>
				</section>
				<section>
					<h3>for, while, if... не влияют на видимость</h3>
					<pre>
						<code class="hljs" data-trim> 
var i;
for (i = 0; i < N; i++) {}

for (var i = 0; i < N; i++) {}
						</code>
					</pre>
				</section>
				<section>
					<h3>Повторное объявление переменных</h3>
					<pre>
						<code class="hljs" data-trim> 
var i = 0;
while (i < N) {}

var i = 100;
var res = N * i;
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Лексическая область видимости</h2>
					<ul>
						<li>Функции имеют не динамическую, а лексическую область видимости</li>
						<li>Вложенная функция обладает возможностью доступа ко всем аргументам и локальным переменным объемлющей функции</li>
						<li>Все переменные внутри функции – это свойства специального внутреннего объекта <span class="highlight-blue">LexicalEnvironment</span></li>
					</ul>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
					<code class="hljs" data-trim>
						function logger(msg) {
    //LexicalEnvironment = { msg: 'Test', date: undefined}
    var date = new Date().toDateString();
    //LexicalEnvironment = { msg: 'Test', date: 'Sun Oct 30 2016'}
    console.log(date + ' : ' + msg);
}

logger('Test');
					</code>
				</pre>
				</section>
				<section>
					<h3>Свойства LexicalEnvironment</h3>
					<ul>
						<li>Объект LexicalEnvironment является внутренним</li>
						<li>Объект скрыт от прямого доступа</li>
						<li>Интерпретатор сначала пытается найти переменную в текущем LE, а затем – во внешнем объекте переменных
						</li>
						<li>Cсылка на внешний объект переменных хранится в специальном внутреннем свойстве [[Scope]]</li>
						<li>При создании функция получает [[Scope]], которое ссылается на LE, в котором она создана</li>
					</ul>
					<pre>
					<code class="hljs" data-trim>
						logger.[[Scope]] = window;
					</code>
				</pre>
				</section>
			</section>
			<section>
				<h2>Как так-то</h2>
				<img src="img/vzryv-mozga.jpg">
			</section>
			<section>
				<h2>...простыми словами</h2>
				<ul>
					<li>Функция при создании получает ссылку [[Scope]] на объект с переменными, в контексте которого создана</li>
					<li>При запуске функции создаётся новый объект с переменными LexicalEnvironment</li>
					<li>При поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке</li>
					===
					<li class="highlight-blue">Функция читает переменные снаружи</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Доступ к внешним переменным</h2>
					<pre>
						<code class="hljs" data-trim>
var date = new Date().toDateString();

function logger(msg) {
     //LexicalEnvironment = { msg: 'Test', date: 'Sun Oct 30 2016'}
     console.log(date + ' : ' + msg);
}

logger('Test');
						</code>
					</pre>
				</section>
				<section>
					<h3>Всегда текущее значение</h3>
					<pre>
						<code class="hljs" data-trim>
var date = new Date().toDateString();

function logger(msg) {
    console.log(date + ' : ' + msg);
}

logger('Test'); //Sun Oct 30 2016 : Test

date = '30.10.2016'

logger('Test 2'); //30.10.2016 : Test 2						
					</code>
					</pre>
				</section>
				<section>
					<h3>Немного усложним</h3>
					<pre>
						<code class="hljs" data-trim>
							function makeCounter() {
    var currentCount = 1;

    return function () {
        return currentCount++;
    };
}

var counter = makeCounter();
//каждый вызов увеличивает счётчик и возвращает результат
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
//если создать другой счётчик, он будет независим от первого
var counter2 = makeCounter();
console.log(counter2()); // 1
						</code>
					</pre>
				</section>
				<section>
					<h3>new Function</h3>
					<pre>
						<code class="hljs" data-trim>
window.a = 1;
function getFunc() {
  var a = 2;
  var func = new Function('', 'alert(a)'); 
  return func;
}
 
getFunc()();// 1
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Итого</h2>
				<blockquote>
					Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны
				</blockquote>
				<ul>
					<li>Значение переменной из внешней области берётся всегда текущее</li>
					<li>Переменную во внешней области видимости можно не только читать, но и изменять</li>
					<li>При создании функции с использованием new Function, [[Scope]] ссылается на window</li>
				</ul>
			</section>
			<!-- End Замыкания-->
			<section>
				<h2>Проверка знаний</h2>
				<pre>
					<code class="hljs" data-trim>
var counter = 5;
var add = (function () {
    var counter = 0;
    return function () {
        return counter += 1;
    }
})();

add();
add();
console.log(add());//???
						</code>
				</pre>
				<p class="fragment">counter = 3</p>
			</section>
			<!--Start ООП в JavaScript -->
			<section>
				<h1>ООП в JavaScript</h1>
				<ul>
					<li>ООП в функциональном стиле</li>
					<li>ООП в прототипном стиле</li>
				</ul>
			</section>
			<section>
				<h2>Стандартные объекты</h2>
				<small>
				<table>
					<tbody>
						<tr>
							<td>Array</td>
							<td>массив пронумерованных элементов</td>
						</tr>
						<tr>
							<td>Boolean</td>
							<td>объект для булевых значений</td>
						</tr>
						<tr>
							<td>Date</td>
							<td>функции для работы с датой и временем</td>
						</tr>
						<tr>
							<td>Error</td>
							<td>объект для представления ошибок</td>
						</tr>
						<tr>
							<td>Function</td>
							<td>каждая функция в JS является объектом класса Function.</td>
						</tr>
						<tr>
							<td>JSON</td>
							<td>содержит методы для разбора объектной нотации JS</td>
						</tr>
						<tr>
							<td>Math</td>
							<td>константы и методы для математических вычислений.</td>
						</tr>
						<tr>
							<td>Number</td>
							<td>объект для работы с числами</td>
						</tr>
						<tr>
							<td>Object</td>
							<td>базовый объект javascript</td>
						</tr>
						<tr>
							<td>RegExp</td>
							<td>позволяет работать с регулярными выражениями.</td>
						</tr>
						<tr>
							<td>String</td>
							<td>управление, форматирование и другие операции с  текстовыми строками</td>
						</tr>
						<tr>
							<td>SyntaxError</td>
							<td>ошибка при интерпретации синтаксически неверного кода</td>
						</tr>
						<tr>
							<td>window</td>
							<td>опредлеяет глобальный объект и окно браузера</td>
						</tr>
					</tbody>
				</table>
				</small>
			</section>
			<section>
				<h1>ОПП в функциональном стиле</h1>
			</section>
			<section>
				<section>
					<h2>Определение конструктора</h2>
					<pre>
						<code class="hljs" data-trim>
						function Person(name, age){
    this.name = name;
    this.age = age;
    this.getName = function(){
        return this.name;
    }
    this.getAge = function(){
        return this.age;
    }
}
					</code>
					</pre>
				</section>
				<section>
					<h3>Пример создания экземпляра</h3>
					<pre>
						<code class="hljs" data-trim>
							var person = new Person('Max', 18);
console.log(person.getName());//Max
console.log(person.getAge()); //18

console.log(person instanceof Object);//true
console.log(person instanceof Person);//true
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>
					Особенности
				</h2>
				<ul>
					<li>Имена конструкторов всегда начинаются с прописной буквы</li>
					<li>Объект явно не создается</li>
					<li>Свойства и метод назначаются непосредственно объекту this</li>
					<li>Для создания экземпляров используется оператор new</li>
					<li>Инструкция return отсутствует</li>
				</ul>
			</section>
			<section>
				<h2>Порядок создания экземпляра</h2>
				<ol>
					<li class="fragment">Создание объекта</li>
					<li class="fragment">Назначение нового объекта переменной this конструктора (после чего this указывает на новый объект)</li>
					<li class="fragment">Выполнение кода внутри конструктора (добавление свойств к новому объекту)</li>
					<li class="fragment">Возвращение нового объекта</li>
				</ol>
			</section>
			<section>
				<section>
					<h2>Проблемы конструкторов</h2>
					<img src="img/hproblem.jpg">
				</section>
				<section>
					<h3>Методы создаются для каждого экземпляра</h3>
					<pre>
						<code class="hljs" data-trim>
							function Person(name, age) {
    this.name = name;
    this.age = age;
    this.getName = new Function('return this.name;');
}

var p1 = new Person('Ira', 23);
var p2 = new Person('Max', 25);
console.log(p1.getName());//Ira
console.log(p2.getName());//Max
console.log(p1.getName == p2.getName); //false

						</code>
					</pre>
				</section>
				<section>
					<h3>Методы создаются для каждого экземпляра</h3>
					<pre>
						<code class="hljs" data-trim>
							function Person(name, age) {
    this.name = name;
    this.age = age;
    this.getName = function() {
        return this.name;
    }
}

var p1 = new Person('Ira', 23);
var p2 = new Person('Max', 25);

console.log(p1.getName()); //Ira
console.log(p2.getName()); //Max
console.log(p1.getName == p2.getName); //false
						</code>
					</pre>
				</section>
				<section>
					<h3>Hot Fix</h3>
					<pre>
						<code class="hljs" data-trim>
					
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.getName = getName
}

function getName(){
    return this.name;
}

var p1 = new Person('Ira', 23);
var p2 = new Person('Max', 25);
console.log(p1.getName == p2.getName); //true
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Внутренний и внешний интерфейс</h2>
					<p>Публичное и приватное свойство</p>
					<pre>
						<code class="hljs" data-trim>
					function Person(name, age) {
    var fAge = 'лет';
    this.name = name;
    this.getAge = function(){
        return age + ' ' + fAge;
    }
}

var person = new Person('Max', 20);
person.name = 'Maxim';
console.log(person.name);//Maxim
console.log(person.getAge());//20 лет	
					</code>
						<pre>
				</section>
				<section>
					<h3>Внутренний и внешний интерфейс</h3>
					<p>Публичный и приватный метод</p>
					<pre>
						<code class="hljs" data-trim>
						function Person(name, age) {
    this.name = name;
    this.getAge = function(){
        return formatAge(age);
    }

    function formatAge(age){
        return age + ' лет';
    }
}

var person = new Person('Max', 20);
console.log(person.formatAge);//undefined
console.log(person.getAge());//20 лет
					</code>
						<pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Сохранение this в замыкании</h2>
					<pre>
						<code class="hljs" data-trim>
function Person(name, age) {
     this.age = age;
     this.printAge = function () {
         setTimeout(console.log(formatAge()), 1000);
     }

     function formatAge() {
         return this.age + ' лет';
     }
}

var person = new Person('Max', 20);
person.printAge(); //undefined лет
						</code>
					</pre>
				</section>
				<section>
					<h3>Сохранение this в замыкании</h3>
					<pre>
						<code class="hljs" data-trim>
function Person(name, age) {
   var self = this;
   this.age = age;
   this.printAge = function(){
       setTimeout(console.log(formatAge()), 1000);
   }
   function formatAge(){
       return self.age + ' лет';
   }
}

var person = new Person('Max', 20);
person.printAge(); //20 лет
					</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Геттеры и сеттеры</h2>
				<pre>
					<code class="hljs" data-trim>
function Person() {
    var _age = 0;
    this.setAge = function (age) {
        if (age <= 0 || age >= 100)
            throw "Значение должно быть больше 0 и меньше 100";

        _age = age;
    }
    this.getAge = function () {
        return _age;
    }
}

var person = new Person();
person.setAge(20);
console.log(person.getAge());//20 
person.setAge(100);//Ex. Значение должно быть больше 0 и меньше 100
					</code>
				</pre>
			</section>
			<section>
				<section>
					<h2>Наследование</h2>
					<pre>
						<code class="hljs" data-trim>
							
function Person(name, age){
    this.name = name;
    this.age = age;
    this.getName = function(){
        return this.name;
    }
    this.getAge = function(){
        return this.age;
    }
}

					</code>
					</pre>
				</section>
				<section>
					<h3>Расширяем</h3>
					<pre>
						<code class="hljs" data-trim>
							function Student(course, group) {
    Person.call(this);
    this.course = course;
    this.group = group;
}

var student = new Student(1, 1);
student.name = 'Peter';
student.age = 24;
console.log(student.name);//Peter
console.log(student.group);//1
						</code>
					</pre>
					<p class="highlight-blue"> Person.call(this);</p>
				</section>
				<section>
					<h3>Переопределение метода</h3>
					<pre>
						<code class="hljs" data-trim>		
function Student(course, group) {
    Person.call(this);
    this.course = course;
    this.group = group;

     this.getAge = function () {
        return this.age + ' лет';
    }
}

var student = new Student(1, 1);
student.age = 20;
console.log(student.getAge()); //20 лет
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Запомним</h2>
				<blockquote>
					<b><span class="highlight-blue">THIS</span></b> в JS не привязывается к объекту, а зависит от контекста вызова. В случае
					с конструктором <span class="highlight-blue">this</span> ссылается на созданный экземпляр при условии использования
					ключевого слова new.
				</blockquote>
			</section>
			<section>
				<h1>ООП в прототипном стиле</h1>
			</section>
			<section>
				<section>
					<h2>Прототип Proto</h2>
					<pre>
						<code class="hljs" data-trim>				
var person = {
    age: 24,
    name: 'Alex'
};

var student = {
    course: 1,
    group: 6
};

student.__proto__ = person;
console.log(student.age);//24
console.log(student.name);//Alex
					</code>
					</pre>
				</section>
				<section>
					<h3>Схема</h3>
					<img src="img/proto.png" />
				</section>
			</section>
			<section>
				<h2>Особенности</h2>
				<ul>
					<li>Объекты можно организовать в цепочки (свойство, не найденное в одном объекте, автоматически ищется в другом)</li>
					<li>Свойство __proto__ доступно во всех браузерах, кроме IE10-</li>
					<li>Объект, на который указывает ссылка __proto__, называется «прототипом»</li>
					<li>Все объекты, созданные объектными литералами, имеют прототип Object.prototype</li>
					<li>Объекты, созданные с помощью new и конструктора, имеют в качестве прототипа значение свойства prototype
					</li>
					<li>Прототип используется только при чтении</li>
				</ul>
			</section>
			<section>
				<h2>Proto: read only</h2>
				<pre>
					<code class="hljs" data-trim>	
var person = {
    age: 24,
    name: 'Alex'
};

var student = {
    course: 1,
    group: 6
};

student.__proto__ = person;
student.age = 10;
console.log(student.age);//10
console.log(person.age);//24
delete student.age;
console.log(person.age);//24
					</code>
				</pre>
			</section>
			<section>
				<h2>Совйство prototype</h2>
				<small>
					<ul>
						<li>Объекты обычно создаются функцией-конструктором через new</li>
						<li>__proto__ не работает в IE10-</li>
					</ul>
				</small>
				<p>Свойство prototype имеет смысл только у конструктора</p>
				<pre>
					<code class="hljs" data-trim>
var person = {
    age: 24,
    name: 'Alex'
};

function Student(course, group) {
    this.course = course,
    this.group = group;
    //this.__proto__ = person; не работает в IE10-
};

Student.prototype = person;//!!!
var student = new Student(1, 1);
console.log(student.age);//24
				</code>
				</pre>
			</section>
			<section>
				<h1>Класс Object</h1>
			</section>
			<section>
				<section>
					<h2>Конструктор</h2>
					<ul>
						<li>Object.length имеет значение 1</li>
						<li>Object.prototype позволяет добавлять свойства ко всем объектам типа Object</li>
					</ul>
					<pre>
						<code class="hljs" data-trim>
var o1 = new Object();
console.log(o1);
var o2 = {};
console.log(o2);
				</code>
					</pre>
				</section>
				<section>
					<h3>Класс Object в разрезе</h3>
					<img src="img/object.png">
					<p>Объект Object.prototype – вершина иерархии, единственный, у которого __proto__ равно null.</p>
				</section>
			</section>
			<section>
				<h2>Метод create</h2>
				<pre>
					<code class="hljs">
var person = {
    age: 20
}

var student = Object.create(person);
console.log(student.age);//20
					</code>
				</pre>
			</section>
			<section>
				<h2>Свойство prototype</h2>
				<pre>
					<code class="hljs">
function Person(){
    this.age = 0;
}

Person.prototype.setAge = function(age){
    this.age = age;
}

Person.prototype.getAge = function(){
    return this.age;
}

var person = new Person();
person.setAge(100);
console.log(person.getAge());//100
					</code>
				</pre>
			</section>
			<section>
				<h2>Метод toString</h2>
				<pre>
					<code class="hljs">
function Person(){
    this.age = 0;
}
var person = new Person();
alert(person);//[object Object]

Person.prototype.toString = function(){
    return this.age;
}

alert(person);//0
					</code>
				</pre>
			</section>
			<section>
				<section>
					<h2>Метод hasOwnProperty</h2>
					<pre>
						<code class="hljs">
var person = {
    age: 24,
    name: 'Alex'
};

var student = {
    course: 1,
    group: 6
};

student.__proto__ = person;

for(var key in student) //course group name age
    console.log(key);
					</code>
					</pre>
				</section>
				<section>
					<h3>hasOwnProperty</h3>
					<pre>
						<code class="hljs">
var person = {
    age: 24,
    name: 'Alex'
};

var student = {
    course: 1,
    group: 6
};

student.__proto__ = person;

for(var key in student) //course group
   if(student.hasOwnProperty(key)) console.log(key);
					</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Метод keys</h2>
				<pre>
					<code class="hljs">
function Person(name) {
    this.name = name;
}
Person.prototype.setName = function (name) {
    this.name = name;
}
Person.prototype.getName = function () {
    return this.name;
}
function Student(course) {
    this.course = course;
}
Student.prototype = Object.create(Person.prototype);
var student = new Student(20);
console.log(Object.keys(student));["course"]
					</code>
				</pre>
			</section>
			<section>
				<section>
					<h2>Метод defineProperty</h2>
					<pre>
						<code class="hljs" data-trim="">
function Person(name) {
    this.name = name;
}
var person = new Person(20);
Object.defineProperty(person, 'age', {
    enumerable: true,
    configurable: true,
    //writable: true, нельзя использовать совместно с get/set
    //value: 0, нельзя использовать совместно с get/set
    get: function(){
        return age + ' лет';
    },
    set: function(newAge){
        age = newAge;
    }
});
person.age = 10;
console.log(person.age);//10
					</code>
					</pre>
				</section>
				<section>
					<h3>Еще один пример</h3>
					<pre>
						<code class="hljs">
function Person(name) {
    this.name = name;
    Object.defineProperty(this, 'age', {
        enumerable: false,
        configurable: true,
        value: 0,
    });
}

var person = new Person(20);
console.log(Object.getOwnPropertyNames(person));//["name", "age"]
console.log(Object.keys(person));//["name"]
					</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Наследование</h2>
					<pre>
						<code class="hljs" data-trim>
function Person(name) {
    this.name = name;
}
Person.prototype.setName = function (name) {
    this.name = name;
}
Person.prototype.getName = function () {
    return this.name;
}
function Student(course, name) {
    Person.call(this, name);
    this.course = course;
}
Student.prototype = Object.create(Person.prototype);
Student.prototype.getCourse = function () {
    return this.course;
}
var student = new Student(10, 'Anna');
console.log(student.getName());//Anna
					</code>
					</pre>
				</section>
				<section>
					<h3>Вызов метода родителя</h3>
					<pre>
						<code class="data-trim">
function Person(name) {
    this.name = name;
}
Person.prototype.setName = function (name) {
    this.name = name;
}
Person.prototype.getName = function () {
    return this.name;
}
function Student(name) {
    Person.call(this, name);
}
Student.prototype = Object.create(Person.prototype);
Student.prototype.getName = function () {
    return 'Name: ' + Person.prototype.getName.call(this);
}
var student = new Student('Anna');
console.log(student.getName());//Name: Anna  
					</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Изменение встроенных прототипов</h2>
				<pre>
					<code class="hljs">
function Person(){
     this.age = 0;
}
var person = new Person();
alert(person);//[object Object]

Person.prototype.toString = function(){
     return this.age;
}

alert(person);//0
					</code>
				</pre>
			</section>
			<section>
				<section>
					<h2>Операторы проверки типов</h2>
					<ul>
						<li>typeof</li>
						<li>instanceof</li>
					</ul>
				</section>
				<section>
					<h3>Оператор typeof</h3>
					<pre>
						<code class="hljs" data-trim>
function A(){}
function B(){}
B.prototype = Object.create(A.prototype);

console.log(typeof undefined);// "undefined"
console.log(typeof 0);// "number"
console.log(typeof true );// "boolean"
console.log(typeof "foo"); // "string"
console.log(typeof {}); // "object"
console.log(typeof null); // "object"
console.log(typeof function(){}); // "function"
var a = new A();
console.log(typeof a);// "object"
var b = new B();
console.log(typeof b);// "object"
						</code>
					</pre>
				</section>
				<section>
					<h3>Оператор instanceof</h3>
					<pre>
						<code class="hljs" data-trim>
function A(){}
function B(){}
B.prototype = Object.create(A.prototype);

var a = new A();
var b = new B();

console.log(a instanceof A);//true
console.log(b instanceof B);//true
console.log(a instanceof B);//false
console.log(b instanceof A);//true
console.log(a instanceof Object);//true
console.log(b instanceof Object);//true
console.log(A.prototype instanceof Object);//true
console.log(B.prototype instanceof Object);//true
console.log(A.prototype instanceof B);//false
console.log(B.prototype instanceof A);//true
console.log(Object.prototype instanceof Object);//false
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h3>Вопрос: как структурировать огромное количество функций и переменных и избежать конфликтов и перезаписи информации?</h2>
					<img src="img/zoo.jpg" height="400" alt="">
			</section>
			<section>
				<section>
					<h2>Пространства имен</h2>
					<pre>
						<code class="hljs">
function Person() {}
function Student() {}
var some_var = 1;
var module1 = {};
module1.data = {a: 1, b: 2};
var module2 = {};
					</code>
					</pre>
				</section>
				<section>
					<h3>Простой пример</h3>
					<pre>
						<code class="hljs">
var MYAPP = {};

MYAPP.Person = function () {};
MYAPP.Student = function () {};

MYAPP.some_var1 = 1;
MYAPP.some_var2 = 2;

MYAPP.modules = {};
MYAPP.modules.modulel = {};
MYAPP.modules.modulel.data = {
    a: 1,
    b: 2
};
MYAPP.modules.module2 = {};
					</code>
					</pre>
				</section>
				<section>
					<h3>Применение пространств имен</h3>
					<pre>
						<code class="hljs">
//применение функции пространства имен 
MYAPP.namespace('MYAPP.modules.module2'); 

//вызов эквивалентен следующей конструкции: 
var MYAPP = { 
      modules: { 
          module2: {} 
      }
}; 
					</code>
					</pre>
				</section>
				<section>
					<h3>Способ реализации</h3>
					<pre>
						<code class="hljs">
var MYAPP = MYAPP || {};
MYAPP.namespace = function (namespaceStr) {
    var parts = namespaceStr.split('.'),
        parent = MYAPP,
        i;
    // отбросить начальный префикс - имя глобального объекта 
    if (parts[0] === "MYAPP") {
        parts = parts.slice(1);
    }
    for (i = 0; i < parts.length; i += 1) {
        // создать свойство, если оно отсутствует 
        if (typeof parent[parts[i]] === "undefined") {
            parent[parts[i]] = {};
        }
        parent = parent[parts[i]];
    }
    return parent;
};
					</code>
					</pre>
				</section>
				<section>
					<h3>Пример работы</h3>
					<pre>
						<code class="hljs">
//присваиваение возвращаемого значение локальной переменной 
var module2 = MYAPP.namespace('MYAPP.modules.module2'); 
module2 === MYAPP.modules.module2; // true 
//отсутствие начального префикса 'MYAPP' 
MYAPP.namespace('modules.module51'); 
//создание глубоко вложенных пространств имен 
MYAPP.namespace('once.upon.a.time.there.was.this.long.nested.property'); 
					</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Создание библиотек и модулей</h2>
				<pre>
					<code class="hljs">
;(function () {
    //приватные переменные
    var version = '0.0.1',
        faculties = ['EEF', 'ITF'];
    //приватные функции
    function Student(name) {
        this.name = name;
    }
    function addStudent(student) {}
    function assignStudentToFaculty(student, faculty) {}
    //основная функция библиотеки
    function bstu(params) {}
    //публичные переменные и функции
    bstu.Student = Student;
    bstu.FACULTY = faculties;
    //экспортируем публичные члены наружу из модуля
    window.BSTU = bstu;
}());
var student = new BSTU.Student('Max');
console.log(student.name);//Max
						</code>
				</pre>
			</section>
			<section>
				<h1>this</h1>
			</section>
			<section>
				<section>
					<h2>Доступ к текущему объекту из метода</h2>
					<pre>
						<code class="hljs" data-trim>
var student1 = {
    course: 3,
    print: function(){
        console.log(course);
    }
};
student1.print();//Ex: Uncaught ReferenceError: course is not defined

var student2 = {
    name: 'Max',
    print: function(){
        console.log(this.name);
    }
};
student2.print();//Max
							</code>
					</pre>
				</section>
				<section>
					<h3>Обращение к объекту по имени переменной</h3>
					<pre>
						<code class="hljs" data-trim>
var student2 = {
    name: 'Max',
    print: function(){
        console.log(student2.name);
    }
};
student2.print();//Max
							</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Особенности this</h2>
				</section>
				<section>
					<h3>Любая функция может иметь в себе this.</h3>
					<pre>
						<code class="hljs" data-trim>
	function func(){ console.log(this); } func();//[object Window]
						</code>
					</pre>
				</section>
				<section>
					<h3>Разный контекст</h3>
					<small>
						<blockquote>
						Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный this. Это значение не зависит от того, как функция была создана, оно определяется в момент вызова	
						</blockquote>
					</small>
					<pre>
						<code class="hljs" data-trim>
function print (){console.log(this.name);}

var person = {
    name: 'Irina',
    print: print
};

var student = {
    name: 'Ivan',
    print: print
};

person.print();//Irina
student.print();//Ivan
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Яаное укзание и привязка контекста</h2>
				<ul>
					<li>Call</li>
					<li>Apply</li>
					<li>Bind</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Метод Call</h2>
					<p>Вызывает функцию с указанным значением this и предоставленными аргументами.</p>
					<pre>
						<code class="hljs" data-trim>
						func.apply(context, [arg1, arg2])
					</code>
					</pre>
				</section>
				<section>
					<h3>
						Пример
					</h3>
					<pre>
						<code class="hljs" data-trim>
function showFullName() {
  console.log(this.firstName + " " + this.lastName);
}

var user = {
  firstName: "Василий",
  lastName: "Петров"
};

//this = user
showFullName.call(user) // "Василий Петров"
				</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Метод Apply</h2>
					<p>Вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива</p>
					<pre>
						<code class="hljs" data-trim>
						func.apply(context, [argsArray])
					</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre><code class="hljs" data-trim>
		var x = 10;
var o = { x: 15 };
function f(message)
{
    console.log(message);
    console.log(this.x);
}
 
f("test");//test 10
f.apply(o, ["test"]);//test 15
	</code></pre>
				</section>
				<section>
					<h3>Использование со встроенными функциями</h3>
					<pre><code class="hljs">
/* мин/макс числа в массиве */
var numbers = [5, 6, 2, 3, 7];

/* используем apply к Math.min/Math.max */
var max = Math.max.apply(null, numbers); 
/* Это эквивалентно Math.max(numbers[0], ...)
или Math.max(5, 6, ...) */

var min = Math.min.apply(null, numbers);	
		</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Метод Bind</h2>
					<ul>
						<li>Cоздаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение.
						</li>
						<li>Bind не вызывает функцию, он только возвращает «обёртку»</li>
					</ul>
					<pre>
						<code class="hljs" data-trim>
						var wrapper = func.bind(context[, arg1, arg2...])
					</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre><code class="hljs" data-trim>
function f(a, b) {
  console.log(this);
  console.log(a + b);
}

var g = f.bind("Context");
g(1, 2); // Context 3
		</code></pre>
				</section>
			</section>
			<section>
				<h2>
					Карринг (currying) параметров
				</h2>
				<blockquote>
					Создание новой функции путём фиксирования аргументов существующей (термин из функционального программирования)
				</blockquote>
				<pre>
					<code class="hljs" data-trim>
function mul(a, b) {
  return a * b;
}
// double умножает только на два
var double = mul.bind(null, 2); 
// контекст фиксируем null, он не используется

console.log(double(3));// mul(2, 3) = 6
console.log(double(4));// mul(2, 4) = 8
console.log(double(5));// mul(2, 5) = 10
					</code>
				</pre>
			</section>
			<section>
				<h2>Одалживание метода</h2>
				<pre>
					<code>
function showArgs() {
  //arguments.length [0] ... [n]
  var argStr = arguments.join(':');
  console.log(argStr); 
}

showArgs(1, 2, 3);// arguments.join is not a function(…)
	</code>
				</pre>
				<pre>
					<code class="hljs" data-trim>
function showArgs() {
  var join = [].join; // скопируем ссылку на функцию в переменную
  // вызовем join с this = arguments,
  // этот вызов эквивалентен arguments.join(':')
  var argStr = join.call(arguments, ':');
  console.log(argStr);
}

showArgs(1, 2, 3);//1:2:3
					</code>
				</pre>
			</section>
			<!-- Объектная модель документа -->
			<section>
				<h1>
					Объектная модель документа
				</h1>
			</section>
			<section>
				<h2>Структура браузерных объектов</h2>
				<img src="img/window.environment.png" alt="">
			</section>
			<section>
				<section>
					<h2>Пример DOM-дерева</h2>
					<script type="text/template">
						<!DOCTYPE HTML>
						<html>

						<head>
							<title>Какой-то заголовок</title>
						</head>

						<body>
							Какой-то текст
						</body>

						</html>
					</script>
					<pre>
						<code class="hljs">
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Какой-то заголовок&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  Какой-то текст
&lt;/body&gt;
&lt;/html&gt;
						</code>
					</pre>
				</section>
				<section>
					<h3>Вид документа</h3>
					<img src="img/dom-view.png">
				</section>
				<section>
					<h3>Типы узлов в примере</h3>
					<ol>
						<li>Теги образуют узлы-элементы (element node). Одни узлы могут быть вложены в другие. Дерево образуется исключительно
							за счет них</li>
						<li>Текст внутри элементов образует текстовые узлы (text node, #text). Текстовый узел содержит исключительно строку текста
							и не может иметь потомков, то есть он всегда на самом нижнем уровне</li>
					</ol>
					<blockquote>
						Пробелы и переводы строки – это тоже текст, полноправные символы, которые учитываются в DOM
					</blockquote>
				</section>
			</section>
			<section>
				<h2>Типы узлов</h2>
				<pre>
					<code class="hljs">
interface Node {
  // Всевозможные значения nodeType
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2;
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4;
  const unsigned short ENTITY_REFERENCE_NODE = 5;
  const unsigned short ENTITY_NODE = 6;
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12;
  ...
}
					</code>
				</pre>
			</section>
			<section>
				<section>
					<h2>Навигация по DOM-элементам</h2>
					<img src="img/dom-links.png" alt="" height="500">
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs" data-trim>
&lt;!DOCTYPE&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Navigation&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="container"&gt;
        &lt;div class="content"&gt;
            &lt;div class="title"&gt;
                &lt;h3&gt;Title 1&lt;/h3&gt;
            &lt;/div&gt;
            &lt;div class="message"&gt;
                &lt;a href="google.com"&gt;google&lt;/a&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;div class="title"&gt;
                &lt;h3&gt;Title 2&lt;/h3&gt;
            &lt;/div&gt;
            &lt;div class="message"&gt;
                &lt;img src="https://www.wired.com/wp-content/uploads/2015/09/google-logo-1200x630.jpg" alt=""&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="navigation.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var example = new NavigationExample();
        example.title();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
						</code>
					</pre>
				</section>
				<section>
					<h3>document.body</h3>
					<p>Запись запрещена, только чтение</p>
					<img src="img/document-body.png" alt="">
				</section>
				<section>
					<h3>document.head</h3>
					<img src="img/document-head.png" alt="">
					<p>Только getter, запись без сохранения результата</p>
					<pre>
						<code class="hljs" data-trim>			
    function head() {
        console.log(document.head);
        document.head = '<h1>Test</h1>';
        console.log(document.head);
    }
						</code>
					</pre>
				</section>
				<section>
					<h3>document.title</h3>
					<img src="img/document-head.png" alt="">
					<p>Getter + Setter</p>
					<pre>
						<code class="hljs" data-trim>		
    function title() {
        console.log(document.title);//Navigation
        document.title = 'Test';
        console.log(document.title);//Test
    }
						</code>
					</pre>
				</section>
				<section>
					<h3>document.links</h3>
					<img src="img/document-links.png" alt="">
					<p>Только getter, запись без сохранения результата</p>
					<pre>
						<code class="hljs" data-trim>		
 function links(){
        console.log(document.links);
        document.links = [];
        console.log(document.links);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>document.images</h3>
					<img src="img/document-images.png" alt="">
					<p>Только getter, запись без сохранения результата</p>
					<pre>
						<code class="hljs" data-trim>		
 function images(){
        console.log(document.images);
        document.images = [];
        console.log(document.images);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>document.documentElement</h3>
					<img src="img/document-documentelement.png" alt="">
					<pre>
						<code class="hljs" data-trim>		
console.log(document.documentElement);
//root element in document (html)
					</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Элементы DOM-дерева</h2>
					<p class="text"><span class="highlight-blue">Дочерние элементы (дети)</span> – элементы, которые лежат непосредственно внутри данного.
						Например, внутри &lt;HTML&gt; обычно лежат &lt;HEAD&gt; и &lt;BODY&gt;.</p>
					<p class="text"><span class="highlight-blue">Потомки</span> – все элементы, которые лежат внутри данного, вместе с их детьми, детьми
						их детей и так далее. То есть, всё поддерево DOM.</p>
				</section>
				<section>
					<h2>Дочерние элементы</h2>
					<ul>
						<li>DOM-коллекции не являются JavaScript-массивами</li>
						<li>В них нет методов массивов (forEach, map, push, pop и т.д)</li>
						<li>Нельзя перебирать коллекцию через for..in</li>
						<li>В мире DOM в качестве значения, обозначающего «нет такого элемента» или «узел не найден», используется не undefined,
							а null.</li>
					</ul>
				</section>
				<section>
					<h3>Расширяем горизонты (forEach для HtmlCollection)</h3>
					<pre>
						<code class="hljs" data-trim>
    function foreach(){
        var collections = document.body.childNodes;
        [].forEach.call(collections, function(item, index){
            console.log(item);
            console.log(index);
        });
    }
						</code>
					</pre>
				</section>
				<section>
					<h3>Свойство Node.childNodes</h3>
					<img src="img/childnodes1.png" alt="">
					<pre>
						<code class="hljs">
 console.log(document.body.childNodes);
						</code>
					</pre>
				</section>
				<section>
					<h3>Свойство Node.childNodes</h3>
					<img src="img/childnodes2.png" alt="">
					<pre>
						<code class="hljs">
 console.log(document.body.childNodes[1].childNodes);
						</code>
					</pre>
				</section>
				<section>
					<h3>Свойство Node.childNodes</h3>
					<img src="img/childnodes2.png" alt="">
					<pre>
						<code class="hljs">
for (var i = 0; i < document.body.childNodes.length; i++) {
      console.log( document.body.childNodes[i] ); 
}

var container = document.getElementById('container');
for (var i = 0; i < container.childNodes.length; i++) {
      console.log( document.body.childNodes[i] ); 
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Свойство Node.firstChild</h3>
					<ul>
						<li>Совйство только для чтения</li>
						<li>Возвращающее первый потомок узла в древе или null, если узел является бездетным</li>
						<li>Если узел это документ, он возвращает первый узел в списке своих прямых детей</li>
					</ul>
				</section>
				<section>
					<h3>Свойство Node.firstChild: пример</h3>
					<img src="img/document-firstchild.png" alt="">
					<pre>
						<code class="hljs">
 function firstChild() {
    console.log(document.body.firstChild);
    console.log(document.body.childNodes.firstChild);
    console.log(document.body.childNodes[1].firstChild);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Свойство Node.lastChild</h3>
					<img src="img/document-lastchild.png" alt="">
					<pre>
						<code class="hljs">
 function firstChild() {
    console.log(document.body.lastChild);
    console.log(document.body.childNodes.lastChild);
    console.log(document.body.childNodes[1].lastChild);
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Соседние элементы и родительский элемент</h2>
					<ul>
						<li>children – только дочерние узлы-элементы, то есть соответствующие тегам</li>
						<li>firstElementChild, lastElementChild – соответственно, первый и последний дети-элементы</li>
						<li>previousElementSibling, nextElementSibling – соседи-элементы</li>
						<li>parentElement – родитель-элемент.</li>
					</ul>
				</section>
				<section>
					<h3>Свойство children</h3>
					<p>В отличии от childNodes, children удаляет текстовые узлы и комментарии</p>
					<img src="img/children.png" alt="" height="250">
					<pre>
						<code class="hljs" data-trim>
	function children(){
        console.log(document.body.children);
        console.log(document.body.children[0].children);
    }
						</code>
					</pre>
				</section>
				<section>
					<h2>firstElementChild</h2>
					<p>Доступное только для чтения свойство ParentNode.firstElementChild возвращает первый дочерный элемент объекта (Element)
						или null если дочерних элементов нет</p>
					<img src="img/firstElementChild.png" alt="">
					<pre><code class="hljs" data-trim>  
	function firstElementChild(){
    console.log(document.body.firstElementChild);
    console.log(document.body.childNodes.firstElementChild);
    console.log(document.body.childNodes[1].firstElementChild);
}

	</code></pre>
				</section>
				<section>
					<h2>lastElementChild</h2>
					<p>Доступное только для чтения свойство ParentNode.firstElementChild возвращает первый дочерный элемент объекта (Element)
						или null если дочерних элементов нет</p>
					<img src="img/lastelementchild.png" alt="">
					<pre><code class="hljs" data-trim>  
 function lastElementChild() {
    console.log(document.body.lastElementChild);
    console.log(document.body.childNodes.lastElementChild);
    console.log(document.body.childNodes[1].lastElementChild);
}
	</code>
	</pre>
				</section>
				<section>
					<h2>nextElementSibling (get only)</h2>
					<p>Содержит узел, который следует сразу за узлом, вызвавшим это свойство или null, если такового не существует</p>
					<img src="img/nextElementSibling.png" alt="" height="200">
					<pre><code class="hljs" data-trim>  
 function nextElement() {
    console.log(document.body.nextElementSibling);
    console.log(document.getElementById('container').children[0].nextElementSibling);
    console.log(document.body.childNodes[1].childNodes[2].nextElementSibling);
}
	</code>
	</pre>
				</section>
				<section>
					<h2>previousElementSibling (get only)</h2>
					<p>Содержит узел, который следует перед узлом, вызвавшим это свойство или null, если такового не существует</p>
					<img src="img/previousElementSibling.png" alt="">
					<pre>
						<code class="hljs" data-trim>  
function prevElement() {
    console.log(document.body.previousElementSibling);
    console.log(document.getElementById('container').children[1].previousElementSibling);
    console.log(document.body.childNodes[1].childNodes[2].previousElementSibling);
}
	</code>
	</pre>
				</section>
				<section>
					<h2>parentElement (get only)</h2>
					<p>
						Возвращает родителя узла DOM Element, или null если узел не имеет родителя, или его родитель не DOM Element
					</p>
					<img src="img/parentElement.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Особые ссылки для таблиц</h2>
					<small>
				<table>
					<tbody>
						<tr>
							<td>table.rows </td>
							<td> коллекция строк TR таблицы</td>
						</tr>
						<tr>
							<td>table.caption/tHead/tFoot</td>
							<td>ссылки на элементы таблицы CAPTION, THEAD, TFOOT</td>
						</tr>
						<tr>
							<td>table.tBodies</td>
							<td>коллекция элементов таблицы TBODY, по спецификации их может быть несколько.</td>
						</tr>
						<tr>
							<td>tbody.rows</td>
							<td>коллекция строк TR секции.</td>
						</tr>
						<tr>
							<td>tr.cells </td>
							<td>коллекция ячеек TD/TH</td>
						</tr>
						<tr>
							<td>tr.sectionRowIndex </td>
							<td>номер строки в текущей секции THEAD/TBODY</td>
						</tr>
						<tr>
							<td>tr.rowIndex  </td>
							<td>номер строки в таблице</td>
						</tr>
						<tr>
							<td>td.cellIndex</td>
							<td>номер ячейки в строке</td>
						</tr>
					</tbody>
				</table>
				</small>
				</section>
				<section>
					<h3>Пример таблицы</h3>
					<pre>
					<code class="hljs" data-trim="">
						 &lt;table id="table"&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;Key&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tfoot&gt;
            &lt;tr&gt;
                &lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tfoot&gt;
        &lt;tbody&gt;
            &lt;tr&gt;
                &lt;td&gt;A&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tbody&gt;
&lt;/table&gt;
					</code>
				</pre>
				</section>
				<section>
					<h3>table.rows</h3>
					<img src="img/table.rows.png" alt="">
					<pre>
					<code class="hljs" data-trim>
						 function rows(){
    var table = document.getElementById('table');
    console.log(table.rows);
}
					</code>
				</pre>
				</section>
				<section>
					<h3>table.tBodies</h3>
					<img src="img/table.tbody.png" alt="">
					<pre>
					<code class="hljs" data-trim>
  function tbody() {
    var table = document.getElementById('table');
    console.log(table.tBodies);
}
					</code>
				</pre>
				</section>
				<section>
					<h3>row.cells</h3>
					<img src="img/table.cells.png" alt="">
					<pre>
					<code class="hljs" data-trim>
 function cells(){
    var row = document.getElementById('table').rows[0];
    console.log(row.cells);
}
					</code>
				</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Поиск элементов</h2>
					<ul>
						<li>getElementById</li>
						<li>getElementsByTagName</li>
						<li>getElementsByName</li>
						<li>getElementsByClassName</li>
						<li>querySelectorAll</li>
						<li>querySelector</li>
						<li>closest</li>
					</ul>
				</section>
				<section>
					<h3>getElementById</h3>
					<p>Оптимизация баузера (работает быстро). Внутреннее соответствие id -> элемент</p>
					<img src="img/document-getElementById.png" alt="">
					<pre>
						<code class="hljs" data-trim>
function getElementById(){
    console.log(document.getElementById('container'));
    console.log(document.getElementById('tag'));
}
						</code>
					</pre>
				</section>
				<section>
					<h3>getElementsByTagName</h3>
					<p>При изменении документа – изменяется и результат запроса</p>
					<img src="img/document-getElementsByTagName.png" alt="" height="300">
					<pre>
											<code class="hljs" data-trim>
function getElementsByTagName(){
    console.log(document.getElementsByTagName('img'));
    console.log(document.getElementsByTagName('div'));
    console.log(document.getElementsByTagName('bla'));
}
						</code>
					</pre>
				</section>
				<section>
					<h3>getElementsByName</h3>
					<img src="img/document-getElementsByName.png" alt="">
					<pre>
											<code class="hljs" data-trim>
  function getElementsByName() {
    console.log(document.getElementsByName('title__1'));
    console.log(document.getElementsByName('content'));
    console.log(document.getElementsByName('img'));
}
						</code>
					</pre>
				</section>
				<section>
					<h3>getElementsByClassName</h3>
					<img src="img/document-getelementbyclassname.png" alt="" height="350">
					<pre>
						<code class="hljs" data-trim>
function getElementsByClassName() {
    console.log(document.getElementsByClassName('content'));
    console.log(document.getElementsByClassName('title'));
    console.log(document.getElementsByClassName('img'));
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Оптимизация запросов getElementsBy...</h3>
					<p>Firefox + IE + Edge</p>
					<blockquote>
						Перебрать подэлементы document.body в порядке их появления в поддереве. Запоминать все найденные элементы во внутренней структуре
						данных, чтобы при повторном обращении обойтись без поиска.
					</blockquote>
					<ol>
						<li>Перебрать подэлементы document.body в порядке их появления в поддереве</li>
						<li>Запоминать все найденные элементы во внутренней структуре данных, чтобы при повторном обращении обойтись без поиска</li>
					</ol>
				</section>
				<section>
					<h3>Оптимизация запросов getElementsBy...</h3>
					<p>Firefox + IE + Edge Пример</p>
					<pre>
						<code class="hljs" data-trim>
var elems = document.getElementsByTagName('div');
console.log(elems[0]);
console.log(elems[995]);
console.log(elems[500]);
console.log(elems.length);
						</code>
					</pre>
					<small>
					<ol>
						<li>Браузер создаёт пустую «живую коллекцию» elems. Пока ничего не ищет</li>
						<li>Перебирает элементы, пока не найдёт первый div. Запоминает его и возвращает</li>
						<li>Перебирает элементы дальше, пока не найдёт элемент с индексом 995. Запоминает все найденные</li>
						<li>Возвращает ранее запомненный элемент с индексом 500, без дополнительного поиска</li>
						<li>Продолжает обход поддерева с элемента, на котором остановился (995) и до конца. Запоминает найденные элементы и возвращает
							их количество</li>
					</ol>
					</small>
				</section>
				<section>
					<h3>Оптимизация запросов getElementsBy...</h3>
					<p>Webkit (Chrome + Safari + Opera)</p>
					<blockquote>
						Перебирать подэлементы document.body. Запоминать только один, последний найденный, элемент, а также, по окончании перебора
						– длину коллекции.
					</blockquote>
					<p>Отличия от предыдущего способа</p>
					<ul>
						<li>Кеширование используется меньше</li>
						<li>Запоминает только последний элемент</li>
						<li>Требует меньше памяти, но менее эффективнее при повторном доступе к предыдущим элементам</li>
						<li>Одинаково хорошо работает при последовательном переборе коллекции, без возврата к ранее выбранным</li>
					</ul>
				</section>
				<section>
					<h3>Оптимизация запросов getElementsBy...</h3>
					<p>Webkit (Chrome + Safari + Opera) Пример</p>
					<pre>
						<code class="hljs" data-trim>
var elems = document.getElementsByTagName('div');
console.log(elems[0]);
console.log(elems[995]);
console.log(elems[500]);
console.log(elems.length);
						</code>
					</pre>
					<small>
<ol>
	<li>Браузер создаёт пустую «живую коллекцию» elems. Пока ничего не ищет.</li>
	<li>Перебирает элементы, пока не найдёт первый div. Запоминает его и возвращает.</li>
	<li>Перебирает элементы дальше, пока не найдёт элемент с индексом 995. Запоминает его и возвращает.</li>
	<li>Браузер запоминает только последний найденный, поэтому не помнит об элементе 500. Нужно найти его перебором поддерева. Этот перебор можно начать либо с начала – вперед по поддереву, 500-й по счету) либо с элемента 995 – назад по поддереву, 495-й по счету. Так как назад разница в индексах меньше, то браузер выбирает второй путь и идёт от 995-го назад 495 раз. Запоминает теперь уже 500-й элемент и возвращает его.</li>
	<li>Продолжает обход поддерева с 500-го (не 995-го!) элемента и до конца. Запоминает число найденных элементов и возвращает его.</li>
</ol>
</small>
				</section>
				<section>
					<h3>querySelectorAll</h3>
					<p>Перебирает все подэлементы внутри элемента и проверяет каждый элемент на соответствие запросу</p>
					<p></p>
					<img src="img/document-queryAll.png" alt="" height="250">
					<pre>
						<code class="hljs" data-trim>
//Результаты поиска сохраняются в кеше пока документ не изменится
function querySelectorAll(){
    console.log(document.querySelectorAll('#container'));
    console.log(document.querySelectorAll('div.content .title'));
}
						</code>
					</pre>
				</section>
				<section>
					<h3>querySelector</h3>
					<img src="img/document-query.png" alt="">
					<pre>
						<code class="hljs" data-trim>
	function querySelector(){
         console.log(document.querySelector('#container'));
         console.log(document.querySelector('div.content .title'));
    }
						</code>
					</pre>
				</section>
				<section>
					<h3>closest</h3>
					<img src="img/element-closest.png" alt="">
					<pre>
						<code class="hljs" data-trim>
 function closest() {
    var link = document.getElementsByTagName('a')[0];
    console.log(link.closest('.content'));
    console.log(document.querySelector('#container'));
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Основные свойства элементов</h2>
					<small>
				<table>
					<tbody>
						<tr>
							<td>attributes</td>
							<td>возвращает все атрибуты элемента</td>
						</tr>
						<tr>
							<td>classList</td>
							<td>возвращает псевдомассив DOMTokenList</td>
						</tr>
							<tr>
							<td>className</td>
							<td>возвращает/задает атрибута class элемента</td>
						</tr>
							<tr>
							<td>clientHeight</td>
							<td>CSSheight + CSSpadding - horizontalScrollHeight</td>
						</tr>
							<tr>
							<td>clientWidth</td>
							<td>CSSwidth + CSSpadding - horizontalScrollWidth</td>
						</tr>
<tr>
	<td>data</td>
	<td>содержимое тестового узла</td>
</tr>
<tr>
	<td>firstElementChild</td>
	<td>возвращает первый дочерный элемент объекта</td>
</tr>
	<tr>
							<td>id</td>
							<td>возвращает идентификатор элемента в DOM</td>
						</tr>
							<tr>
							<td>innerHTML</td>
							<td>возвращает/задает HTML-содержимое в виде строки</td>
						</tr>
						<tr>
							<td>hidden</td>
							<td>возвращает/задает видимость узла</td>
						</tr>
							<tr>
							<td>name</td>
							<td>возвращает/задает атрибут name</td>
						</tr>
<tr>
	<td>outerHTML</td>
	<td>возвращает HTML (при записи заменяется на новый)</td>
</tr>
							<tr>
							<td>scroll[Height...]</td>
							<td>высота контента, включая содержимое, невидимое из-за прокрутки</td>
						</tr>
<tr>
	<td>shadowRoot</td>
	<td>внутренний DOM элемента</td>
</tr>
							<tr>
							<td>tagName</td>
							<td>возвращает HTML-тег элемента</td>
						</tr>
					</tbody>
				</table>
			</small>
				</section>
				<section>
					<h3>attributes</h3>
					<img src="img/element-attributes.png" alt="">
					<pre>
						<code class="hljs" data-trim>
function attributes() {
    var container = document.getElementById('container');
    console.log(container.attributes);
    var link = document.getElementsByTagName('a')[0];
    console.log(link.attributes);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>innerHTML & outerHTML</h3>
					<pre>
						<code class="hljs" data-trim>
 function html() {
    var container = document.getElementById('container');
    console.log(container.innerHTML);
    console.log(container.outerHTML);
    container.outerHTML = '<span>Text</span>';
    console.log(container.outerHTML);//empty
    console.log(document.getElementById('container'));//null
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Основные методы элемента</h2>
					<table>
						<tbody>
							<tr>
								<td>hasAttribute</td>
								<td>проверяет наличие атрибута</td>
							</tr>
							<tr>
								<td>getAttribute</td>
								<td>получает значение атрибута</td>
							</tr>
							<tr>
								<td>setAttribute</td>
								<td>устанавливает атрибут</td>
							</tr>
							<tr>
								<td>removeAttribute</td>
								<td>удаляет атрибут</td>
							</tr>
							<tr>
								<td>contains</td>
								<td>проверка вложенности элементов</td>
							</tr>
							<tr>
								<td>matches</td>
								<td>проверка соответствия указаному css-селектору</td>
							</tr>
							<tr>
								<td>remove</td>
								<td>удаляет узел из дерева DOM</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Работа с аттрибутами</h3>
					<pre>
						<code class="hljs" data-trim>
function attribute() {
    var link = document.getElementsByTagName('a')[0];
    console.log(link.hasAttribute('href'));//true
    console.log(link.getAttribute('href'));//http://google.com
    console.log(link.getAttribute('class'));//link
    link.setAttribute('href', 'habrahabr.ru');
    console.log(link.getAttribute('href'));//habrahabr.ru
    link.removeAttribute('href');
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример matches</h3>
					<pre>
						<code class="hljs" data-trim>
 function matches() {
    var link = document.getElementsByTagName('a')[0];
    console.log(link.matches('a'));//true
    console.log(link.matches('.link'));//true
    console.log(link.matches('#container a'));//true
    console.log(link.matches('.message a'));//true
    console.log(link.matches('a.message'));//false
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Добавление и удаление узлов</h2>
					<small>
						<table>
							<tbody>
								<tr>
									<td>createElement</td>
									<td>Создает новый элемент с указанным тегом</td>
								</tr>
								<tr>
									<td>createTextNode</td>
									<td>Создает новый текстовый узел с указанным текстом</td>
								</tr>
								<tr>
									<td>appendChild</td>
									<td>Добавляет elem в конец дочерних элементов parentElem</td>
								</tr>
								<tr>
									<td>insertBefore</td>
									<td>Вставляет elem в коллекцию детей parentElem, перед элементом nextSibling</td>
								</tr>
								<tr>
									<td>cloneNode</td>
									<td>Клонирование узлов</td>
								</tr>
								<tr>
									<td>removeChild</td>
									<td>Удаляет elem из списка детей parentElem</td>
								</tr>
								<tr>
									<td>replaceChild</td>
									<td>Среди детей parentElem удаляет elem и вставляет на его место newElem</td>
								</tr>
							</tbody>
						</table>
					</small>
				</section>
				<section>
					<h3>Добавление элемента</h3>
					<img src="img/element-appendchild.png" alt="">
					<pre>
						<code class="hljs" data-trim>
 function create(){
    var div = document.createElement('div');
    div.className = 'test';
    div.id = 'test';
    var container = document.querySelector('#container');
    container.appendChild(div);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Клонирование элемента</h3>
					<img src="img/element-clone.png" alt="">
					<pre>
						<code class="hljs" data-trim>
function clone(){
    var title = document.querySelector('.title');
    console.log(title.cloneNode());
    console.log(title.cloneNode(true));
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Замена элемента</h3>
					<img src="img/element-replace.png" alt="">
					<pre>
						<code class="hljs" data-trim>
function replace() {
    var title = document.querySelector('.title'),
        h3 = title.firstElementChild;
    var div = document.createElement('div');
    div.className = 'test';
    div.id = 'test';
    div.innerHTML = '<span>Test</span>';
    title.replaceChild(div, h3);
    console.log(title);
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h1>События</h1>
			</section>
			<section>
				<h2>Браузерные события</h2>
				<small>
				<ul>
					<li>Событие – это сигнал от браузера о том, что что-то произошло.</li>
					<li>Тип события - это строка, определяющая тип действия, вызвавшего событие (mousemove, click..).</li>
					<li>Цель события - это объект, в котором возникло событие или с которым это событие связано(Window, Document и Element).</li>
					<li>Обработчик события - это функция, которая обрабатывает, или откликается на событие.</li>
					<li>Объект события - это объект, связанный с определенным событием и содержащий информацию об этом событии. Объекты событий передаются функции обработчика события в виде аргумента.
					<li>Распространение события - это процесс, в ходе которого браузер решает, в каких объектах следует вызвать обработчики событий.</li>
				</ul>
				</small>
			</section>
			<section>
				<section>
					<h2>Обработчик события</h2>
					<blockquote>
						Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло. Именно благодаря обработчикам
						JavaScript-код может реагировать на действия посетителя
					</blockquote>
					<p>Существует несколько способов назначения обработчика события</p>
				</section>
				<section>
					<h3>
						Использование атрибута HTML
					</h3>
					<pre>
						<code class="hljs" data-trim>
<element onclick="script"></element>

</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
<input value="click me" onclick="alert('Click!')" type="button">
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
<p id="text" onclick="setColor()">Click me to change my text color</p>

function myFunction() {
    document.getElementById("text").style.color = "red";
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Использование свойства DOM-объекта</h3>
					<pre>
						<code class="hljs" data-trim>
							<input id="elem" type="button" value="Нажми меня" />
<script>
  elem.onclick = function() {
    alert( 'Спасибо' );
  };
</script>
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
							<input type="button" id="elem" onclick="alert('До')" value="Нажми меня" />
<script>
  elem.onclick = function() { // перезапишет существующий обработчик
    alert( 'После' ); // выведется только это
  };
</script>
						</code>
					</pre>
				</section>
				<section>
					<h3>Доступ к элементу через this</h3>
					<p class="text">Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором он сработал. Это можно использовать,
						чтобы получить свойства или изменить элемент.</p>
					<pre>
						<code class="hljs" data-trim>
							<button onclick="alert(this.innerHTML)">Нажми меня</button>//Нажми меня
						</code>
					</pre>
				</section>
				<section>
					<h3>addEventListener</h3>
					<pre>
						<code class="hljs" data-trim>
element.addEventListener(event, handler[, phase]);
						</code>
					</pre>
					<ul>
						<li>event - Имя события, например click</li>
						<li>handler- Ссылка на функцию, которую надо поставить обработчиком</li>
						<li>phase - Необязательный аргумент, «фаза», на которой обработчик должен сработать</li>
					</ul>
					<pre>
						<code class="hljs" data-trim>
elem.addEventListener( "click" , function() {
	console.log('Thank you!');
});
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
function thanks(){
	console.log('Thank you!');
}
elem.addEventListener( "click" ,  thanks);
						</code>
					</pre>
				</section>
				<section>
					<h3>Еще пример addEventListener</h3>
					<pre>
						<code class="javascript hljs" data-trim>
							&lt;input id="elem" type="button" value="Нажми меня"/&gt;
&lt;script&gt;
  function handler1() {
    alert('Спасибо!');
  };

  function handler2() {
    alert('Спасибо ещё раз!');
  }

  elem.onclick = function() { alert("Привет"); };
  elem.addEventListener("click", handler1); // Спасибо!
  elem.addEventListener("click", handler2); // Спасибо ещё раз!
&lt;/script&gt;
						</code>
					</pre>
				</section>
				<section>
					<h3>removeEventListener</h3>
					<p>Передается таже функция-обработчик, которая была назначена на событие</p>
					<pre>
						<code class="hljs" data-trim>
							// передать те же аргументы, что были у addEventListener
element.removeEventListener(event, handler[, phase]);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
							elem.addEventListener( "click" , function() {alert('Спасибо!')});
// ....не сработает
elem.removeEventListener( "click", function() {alert('Спасибо!')});
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
							elem.addEventListener( "click" , function() {alert('Спасибо!')});
// ....не сработает
elem.removeEventListener( "click", function() {alert('Спасибо!')});
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
function handler() {
  alert( 'Спасибо!' );
}
input.addEventListener("click", handler);
// ....
input.removeEventListener("click", handler);

						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Создание события</h2>
					<ul>
						<li>Event()</li>
						<li>EventTarget.dispatchEvent()</li>
						<li>CustomEvent()</li>
					</ul>
				</section>
				<section>
					<h3>Event</h3>
					<pre>
						<code class="hljs" data-trim>
							event = new Event(typeArg, eventInit);
						</code>
					</pre>
					<ul>
						<li>Тип события – может быть как своим, так и встроенным, к примеру "click".</li>
						<li>Флаги – объект вида { bubbles: true/false, cancelable: true/false }....</li>
					</ul>
					<pre>
						<code class="hljs" data-trim>
							// create a look event that bubbles up and cannot be canceled

var ev = new Event("look", {"bubbles":true, "cancelable":false});
document.dispatchEvent(ev);
						</code>
					</pre>
				</section>
				<section>
					<h3>dispatchEvent</h3>
					<ul>
						<li>Отправляет событие в общую систему событий</li>
						<li>Cобытие подчиняется тем же правилам поведения (захват и всплытие) как и непосредственно инициированные события</li>
					</ul>
					<pre>
					<code class="hljs" data-trim>
						cancelled = !target.dispatchEvent(event)
//event - объект события, который инициализируется
//target - используется для инициализации Event.target 
//и установки события, которое обработчик вызывает
//return - false если хотя бы один из обработчиков 
//этого события вызовал preventDefault
					</code>
	</pre>
					<pre>
						<code class="hljs" data-trim="">
&lt;button id="elem" onclick="alert('Клик');"&gt;Автоклик&lt;/button&gt;
&lt;script&gt;
  var event = new Event("click");
  elem.dispatchEvent(event);
&lt;/script&gt;
						</code>
					</pre>
				</section>
				<section>
					<h3>CustomEvent</h3>
					<p>
						Идентичен Event(), НО у второго аргумента-объекта есть дополнительное свойство detail, в котором можно указывать дополнительную
						информацию
					</p>
					<pre>
						<code class="hljs" data-trim>							
&lt;h1 id="elem"&gt;Element&lt;/h1&gt;

&lt;script&gt;
var elem = document.getElementById('elem');
  elem.addEventListener("hello", function(event) {
    console.log( event.detail.name );
  }, false);

  var event = new CustomEvent("hello", {
    detail: { name: "something" }
  });

  elem.dispatchEvent(event);
&lt;/script&gt;
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Типы событий</h2>
				<ul>
					<li>События мыши</li>
					<li>События документа Window</li>
					<li>События клавиатуры</li>
					<li>События формы и ЭУ</li>
					<li>События буфера обмена</li>
					<li>События перетаскивания</li>
					<li>События медиа</li>
					<li>События CSS</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Объект события</h2>
					<img src="img/event.png" alt="">
					<pre>
					<code class="hljs" data-trim>
<form id="el1">
    <input type="submit" id="el2" value="Save">
</form>
<script>
function onClick(e) {
    console.log(e);
}
document.getElementById('el1').addEventListener('click', onClick);
</script>	
					</code>
				</pre>
				</section>
				<section>
					<h3>Основные свойства и методы</h3>
					<small>
					<table>
						<tbody>
							<tr>
								<td>type</td>
								<td>тип события</td>
							</tr>
							<tr>
								<td>currentTarget</td>
								<td>элемент, на котором сработал обработчик</td>
							</tr>
							<tr>
								<td>target</td>
								<td>целевой элемент (там, где произошло событие)</td>
							</tr>
							<tr>
								<td>bubbles</td>
								<td>является ли данное событие всплывающим</td>
							</tr>
							<tr>
								<td>cancelable</td>
								<td>является ли событие отменяемым</td>
							</tr>
							<tr>
								<td>isTrusted</td>
								<td>было ли событие инициировано действиями пользователя</td>
							</tr>
							<tr>
								<td>preventDefault()</td>
								<td>останавливает событие (если оно cancelable) без остановки высплытия</td>
							</tr>
							<tr>
								<td>stopImmediatePropagation()</td>
								<td>останавливает цепочку вызова событий для последующих слушателей DOM элемента и текущих событий</td>
							</tr>
							<tr>
								<td>stopPropagation()</td>
								<td>останавливает цепочку вызова событий для последующих слушателей DOM элемента (на текущем элементе все обработчики
									отработают)
								</td>
							</tr>
						</tbody>
					</table>
					</small>
				</section>
				<section>
					<h3>Всплытие событий</h3>
					<img src="img/event-bubling.jpg" alt="" height="400">
				</section>
				<section>
					<h3>Пример всплытия событий</h3>
					<img src="img/event5.png" alt="">
					<pre>
					<code class="hljs" data-trim>
<form id="el1">
    <input type="button" id="el2" value="Save">
</form>
<script>
function onClick(e) {
    console.log(e);
}
var element = document.getElementById('el1');
element.addEventListener('click', onClick, true);
element.addEventListener('click', function(e){console.log(e);}, true);
document.getElementById('el2').addEventListener('click', onClick);
</script>
					</code>
				</pre>
				</section>
				<section>
					<h3>Метод stopImmediatePropagation</h3>
					<img src="img/event3.png" alt="">
					<pre>
					<code class="hljs" data-trim>
<form id="el1">
    <input type="button" id="el2" value="Save">
</form>
<script>
function onClick(e) {
    console.log(e);
    e.stopImmediatePropagation();
}
document.getElementById('el1').addEventListener('click', onClick);
document.getElementById('el1').addEventListener('click', onClick);
document.getElementById('el2').addEventListener('click', onClick);
</script>
					</code>
				</pre>
				</section>
				<section>
					<h3>Метод stopPropagation</h3>
					<img src="img/event4.png" alt="">
					<pre>
					<code class="hljs" data-trim>
<form id="el1">
    <input type="button" id="el2" value="Save">
</form>
<script>
function onClick(e) {
    console.log(e);
    e.stopPropagation();
}
var elem = document.getElementById('el1');
elem.addEventListener('click', onClick, true);
elem.addEventListener('click', function(e){console.log(e);}, true);
document.getElementById('el2').addEventListener('click', onClick);
</script>
					</code>
				</pre>
				</section>
				<section>
					<h3>Метод preventDefault</h3>
					<img src="img/event2.png" alt="">
					<pre>
					<code class="hljs" data-trim>
<form id="el1">
	<input type="submit" id="el2" value="Save">
</form>
<script>
function onClick(e) {
    console.log(e);
    e.preventDefault();
    return false;//любое значение кроме false
}
document.getElementById('el1').addEventListener('click', onClick);
document.getElementById('el2').addEventListener('click', onClick);
</script>
					</code>
				</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>События мыши</h2>
					<small>
				<table>
					<tbody>
						<tr>
							<td>click</td>
							<td>нажатие на элемент левой кнопкой мыши</td>
						</tr>
						<tr>
							<td>dblclick</td>
							<td>двойное нажатие на элемент левой кнопкой мыши</td>
						</tr>
						<tr>
							<td>contextmenu</td>
							<td>нажатие на элемент правой кнопкой мыши</td>
						</tr>
						<tr>
							<td>mouseover</td>
							<td>при наведении мыши на элемент</td>
						</tr>
						<tr>
							<td>mousedown</td>
							<td>при нажатии мышью на элемент</td>
						</tr>
						<tr>
							<td>mouseup </td>
							<td>при отжатии мыши на элементе</td>
						</tr>
						<tr>
							<td>mousemove</td>
							<td>при движении мыши</td>
						</tr>
						<tr>
							<td>onwheel</td>
							<td>при передвижении колеса мыши над элементом</td>
						</tr>
					</tbody>
				</table>
				</small>
				</section>
				<section>
					<h3>Простой пример</h3>
					<pre>
					<code class="hljs" data-trim>
<div id="test"></div>

<script>
  document.getElementById("test").addEventListener("click", function(ev) {
    ev.target.innerHTML = "click count: " + ev.detail;
	ev.target.classList.toggle("red");
  }, false);
</script>
					</code>
				</pre>
				</section>
				<section>
					<h3>Модификаторы shift, alt, ctrl, meta (Mac)</h3>
					<pre>
					<code class="hljs" data-trim>	
<button>Alt+Shift+Кликни меня!</button>

<script>
  document.body.children[0].onclick = function(e) {
    if (!e.altKey || !e.shiftKey) return;
    alert( 'Ура!' );
  }
</script>
					</code>
				</pre>
				</section>
				<section>
					<h3>Координаты</h3>
					<pre>	
					<code class"hljs" data-trim>
<input type="button" id="click" value="Click me">
<script>
    function onClick(e) {
        console.log(e.clientX);//относительно окна
        console.log(e.clientY);
        console.log(e.pageX); //относительно документа
        console.log(e.pageY);
    }
    document.getElementById('click').addEventListener('click', onClick);
</script>
					</code>
				</pre>
				</section>
				<section>
					<h3>Client[X,Y] vs Page[X, Y]</h3>
					<img src="img/pagevsclient.png" alt="">
				</section>
				<section>
					<h3>Получение информации о кнопке</h3>
					<pre><code class="hljs" data-trim>
<input type="button" id="click" value="Click me">
<script>
	function onClick(e) {
        console.log(e.which);
        /*
		event.which == 1 – левая кнопка
		event.which == 2 – средняя кнопка
		event.which == 3 – правая кнопка
        */
    }
    document.getElementById('click').addEventListener('click', onClick);
</script>
	</code>
	</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>События документа Window</h2>
					<table>
						<tbody>
							<tr>
								<td>DOMContentLoaded</td>
								<td>HTML загружен и обработан, DOM полностью построена и доступна</td>
							</tr>
							<tr>
								<td>load</td>
								<td>браузер загрузил все ресурсы</td>
							</tr>
							<tr>
								<td>beforeunload/unload</td>
								<td>при уходе со страницы</td>
							</tr>
							<tr>
								<td>resize</td>
								<td>браузер изменил размеры окна</td>
							</tr>
							<tr>
								<td>error</td>
								<td>при запуске/загрузке ресурса происходит ошибка</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Пример DOMContentLoaded</h3>
					<pre>
					<code class="hljs" data-trim>
&lt;script&gt;
  function ready() {
    console.log( 'DOM готов' );
    console.log( "Размеры картинки: " 
		+ img.offsetWidth + "x" 
		+ img.offsetHeight );
//не дожидаемся загрузки картинки ( 0x0 )
  }

  document.addEventListener("DOMContentLoaded", ready);
&lt;/script&gt;
&lt;img id="img" src="/logos/doodles/2016/holidays-2016-2748273943.gif"&gt;
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример load</h3>
					<pre>
					<code class="hljs">
&lt;script&gt;
  window.onload = function() {
    console.log('Документ и все ресурсы загружены');
  };
&lt;/script&gt;
&lt;iframe src="https://example.com/" style="height:60px"&gt;&lt;/iframe&gt;
&lt;script src="index.js"&gt;&lt;/script&gt;
					</code>
				</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>События клавиатуры</h2>
					<table>
						<tbody>
							<tr>
								<td>keyup</td>
								<td>отпускание клавиши</td>
							</tr>
							<tr>
								<td>keydown</td>
								<td>нажатие клавиши</td>
							</tr>
							<tr>
								<td>keypress</td>
								<td>приводит к появлению символа</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Пример keydown</h3>
					<pre>
					<code class="hljs" data-trim>
						 <input type="text" id="text">
<script>
    function onKeyUp(e) {
        e.target.style.background = (e.keyCode == 32)
        ? 'violet'
        : '';
    }
    document.getElementById('text').addEventListener('keyup', onKeyUp);
</script>
					</code>
				</pre>
				</section>
				<section>
					<h3>Кроссбраузерный подход</h3>
					<pre>
					<code class="hljs">
// event.type должен быть keypress
function getChar(event) {
  if (event.which == null) { // IE
    if (event.keyCode < 32) return null; // спец. символ
    return String.fromCharCode(event.keyCode)
  }

  if (event.which != 0 && event.charCode != 0) { // все кроме IE
    if (event.which < 32) return null; // спец. символ
    return String.fromCharCode(event.which); // остальные
  }

  return null; // спец. символ
}
//Код символа хранится в свойствах: charCode и which. Не совместимость
					</code>
				</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>События форм и ЭУ</h2>
					<table>
						<tbody>
							<tr>
								<td>blur</td>
								<td>при потере элементов фокуса</td>
							</tr>
							<tr>
								<td>change</td>
								<td>по окончании изменении значения элемента формы</td>
							</tr>
							<tr>
								<td>focus</td>
								<td>при получении элементов фокуса</td>
							</tr>
							<tr>
								<td>invalid</td>
								<td>при получении элементом статуса invalid</td>
							</tr>
							<tr>
								<td>select</td>
								<td>при выборе пользователем элемента</td>
							</tr>
							<tr>
								<td>submit</td>
								<td>при отправке формы на сервер</td>
							</tr>
							<tr>
								<td>input</td>
								<td>срабатывает тут же при изменении значения текстового элемента</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Change</h3>
					<blockquote>
						Для текстовых элементов означает, что событие произойдёт не при каждом вводе, а при потере фокуса
					</blockquote>
					<pre>
					<code class="hljs">
<input type="text" id="text">
<script>
    function onChange(e) {
        e.target.value += ';';
    }
    document.getElementById('text').addEventListener('change', onChange);
</script>
					</code>
				</pre>
				</section>
				<section>
					<h3>Invalid</h3>
					<pre>
					<code class="hljs">
<form>
    <input type="text" id="text" pattern=".{6,}" required>
	<input type="submit" value="Save">
</form>
    
<script>
    function onInvalid() {
        console.log('Must contain 6 or more characters');
    }
    document.getElementById('text').addEventListener('invalid', onInvalid);
</script>
					</code>
				</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>События буфера обмена</h2>
					<table>
						<tbody>
							<tr>
								<td>copy</td>
								<td>копирование значения</td>
							</tr>
							<tr>
								<td>paste</td>
								<td>вставки значения</td>
							</tr>
							<tr>
								<td>cut</td>
								<td>вырезании значения</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>DataTransfer</h3>
					<p>clipboardData использует объект dataTransfer</p>
					<pre>
					<code class="hljs" data-trim="">
void dataTransfer.setData(format, data);
//text/plain
//text/uri-list
//text/html
					</code>
				</pre>
					<pre>
					<code class="hljs" data-trim>
						 DataTransfer.clearData([format]);
					</code>
				</pre>
					<pre>
					<code class="hljs" data-trim>
						 DOMString dataTransfer.getData(format);
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs" data-trim>
&lt;input type="text" id="text"&gt;
&lt;script&gt;
    function onCopy(e) {
        e.clipboardData.setData('text/plain', 'Something');
    }
    document.getElementById('text').addEventListener('copy', onKeyUp);
&lt;/script&gt;
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>
						События перетаскивания
					</h2>
					<table>
						<tbody>
							<tr>
								<td>drag</td>
								<td>при перетаскивании элемента</td>
							</tr>
							<tr>
								<td>dragstart</td>
								<td>когда элемент начинает перемещаться</td>
							</tr>
							<tr>
								<td>dragenter</td>
								<td>когда перемещаемый элемент попадает на элемент-назначение</td>
							</tr>
							<tr>
								<td>drop</td>
								<td>после отпускания элемента</td>
							</tr>
							<tr>
								<td>DataTransfer</td>
								<td>объект используется для хранения данных, перетаскиваемых мышью во время операции drag and drop</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Алгоритм Drag’n’Drop</h3>
					<ol>
						<li>Отслеживаем нажатие кнопки мыши на переносимом элементе при помощи события mousedown</li>
						<li>При нажатии – подготовить элемент к перемещению</li>
						<li>Отслеживаем движение мыши через mousemove</li>
						<li>Передвигаем переносимый элемент на новые координаты путём смены left/top и position:absolute</li>
						<li>При отпускании кнопки мыши (mouseup) – остановить перенос элемента</li>
						<li>Дополнительные действия, связанные с окончанием Drag’n’Drop</li>
					</ol>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
					<code class="js" data-trim>
&lt;div id="div1" ondrop="drop(event)" ondragover="allowDrop(event)"&gt;&lt;/div&gt;
&lt;img id="drag1" src="img.gif" draggable="true" ondragstart="drag(event)"&gt;

&lt;script&gt;
function allowDrop(ev) {
    ev.preventDefault();
}

function drag(ev) {
    ev.dataTransfer.setData("text", ev.target.id);
}

function drop(ev) {
    ev.preventDefault();
    var data = ev.dataTransfer.getData("text");
    ev.target.appendChild(document.getElementById(data));
}
&lt;/script&gt;
					</code>
				</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>События медиа (video, image, audio...)</h2>
					<table>
						<tbody>
							<tr>
								<td>onpause </td>
								<td>медиа-объект приостанавливает выполнение программно или в ответ на действие пользователя</td>
							</tr>
							<tr>
								<td>play</td>
								<td>медиа-объект готов к началу выполнению</td>
							</tr>
							<tr>
								<td>playing</td>
								<td>медиа-объект выполняется</td>
							</tr>
							<tr>
								<td>progress</td>
								<td>возникает при изменении состояния получения данных медиа-объектом</td>
							</tr>
							<tr>
								<td>volumechange</td>
								<td>возникает при изменении уровня громкости</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Pause</h3>
					<pre>
					<code class="hljs" data-trim="">
						&lt;video id="myVideo" width="320" height="176" controls&gt;
  &lt;source src="mov_bbb.mp4" type="video/mp4"&gt;
  &lt;source src="mov_bbb.ogg" type="video/ogg"&gt;
  Your browser does not support HTML5 video.
&lt;/video&gt;

&lt;script&gt;
var vid = document.getElementById("myVideo");
vid.onpause = function() {
    alert("The video has been paused");
};
&lt;/script&gt; 
					</code>
				</pre>
				</section>
				<section>
					<h3>volumechange</h3>
					<pre>
					<code class="hljs">
&lt;video controls id="myVideo"&gt;
  &lt;source src="mov_bbb.mp4" type="video/mp4"&gt;
  &lt;source src="mov_bbb.ogg" type="video/ogg"&gt;
  Your browser does not support HTML5 video.
&lt;/video&gt;

&lt;script&gt;
document.getElementById("myVideo").addEventListener("volumechange", myFunction);

function myFunction(e) {
   alert(e.target.volume);//[0-1]
   alert("The volume has been changed!");
}
&lt;/script&gt;
					</code>
				</pre>
				</section>
			</section>
			<section>
				<h2>События CSS</h2>
				<table>
					<tbody>
						<tr>
							<td>transitionend </td>
							<td>при завершении CSS-анимации</td>
						</tr>
					</tbody>
				</table>
				<pre>
						<code class="hljs" data-trim>
/*
 * Прослушиваем событие transitionend на определенном элементе, 
 * Затем, вызваем определенную функцию (showMessage)
 */
function showMessage() {
    alert('Transition закончил свое выполнение');
}

var element = document.getElementById("slidingMenu");
element.addEventListener("transitionend", showMessage, false);
						</code>
					</pre>
			</section>
			<section>
				<h1>Event loop</h1>
			</section>
			<section>
				<h2>JS vs Потоки</h2>
				<blockquote>Javascript работает в одном потоке</blockquote>
				<ul>
					<li>Текущая функция не может быть приостановлена</li>
					<li>Текущая функция должна завершить свое выполнение до начала выполнения другой функции</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Модель событийного цикла</h2>
					<img src="img/lifecircle.svg" alt="" height="450">
				</section>
				<section>
					<h3>Общий стек вызовов функций</h3>
					<ul>
						<li>Вызов любой функции создает контекст выполнения</li>
						<li>При вызове вложенной функции создается новый контекст</li>
						<li>Старый контекст сохраняется в специальной структуре</li>
					</ul>
					<pre>
				<code class="hljs">
function f(b) {
  var a = 12;
  return a + b + 35;
}

function g(x) {
  var m = 4;
  return f(m * x);
}

g(21);
				</code>
			</pre>
				</section>
				<section>
					<h3>Алгоритм работы со стеком</h3>
					<ol>
						<li>При вызывается <span class="highlight-blue">g</span>, создаётся область видимости, содержащая аргументы g и локальные
							переменные.
						</li>
						<li>При вызове <span class="highlight-blue">f</span>, создаётся вторая область видимости и помещается в стэк вперед первой,
							которая содержит аргументы f и её локальные переменные.</li>
						<li>Когда <span class="highlight-blue">f</span> возвращает результат, верхний элемент из стека удаляется.</li>
						<li>Когда <span class="highlight-blue">g</span> возвращает результат, контекст функции удаляется, и стэк будет пуст.</li>
					</ol>
				</section>
				<section>
					<h2>Куча</h2>
					<p>Объекты размещаются в куче. Куча — это ссылка на определённую неструктурированную области памяти.</p>
				</section>
				<section>
					<h3>Очередь событий</h3>
					<blockquote>
						Очередь событий — это список событий, подлежащих обработке
					</blockquote>
					<ul>
						<li>Каждое событие связано с некоторой функцией</li>
						<li>Когда на стэке освобождается достаточно места, событие извлекается из очереди и обрабатывается</li>
						<li>Обработка события состоит в вызове этой функции (создание начального контекста выполнения)</li>
						<li>Обработка события заканчивается, когда стек становится пустым.</li>
					</ul>
				</section>
				<section>
					<h3>Очередь событий</h3>
					<pre>
					<code class="hljs">
while(queue.waitForMessage()){
    queue.processNextMessage();
}
					</code>
				</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Особенности event loop</h2>
				</section>
				<section>
					<h3>Нулевые задержки</h3>
					<blockquote>
						Задержка – это минимальное время, которое требуется среде выполнения на обработку запроса.
					</blockquote>
					<ul>
						<li>Нулевая задержка не дает гарантии, что обработчик выполнится через 0 миллисекунд.</li>
						<li>Вызов setTimeout с аргументом 0 не завершится за указанное время.</li>
						<li>Выполнение зависит от количества ожидающих в очереде задач.</li>
					</ul>
				</section>
				<section>
					<h3>Никогда не блокируется</h3>
					<ul>
						<li>Поток выполнения никогда не блокируется</li>
						<li>Обработка I/O осуществляется с помощью событий и/или функций обратного вызова</li>
						<li>В момент ожидания события могут обрабатыватья другие процессы (пользовательский ввод)</li>
						<li>Страница в браузере работает в одном потоке. Это значит, что браузер либо выполняет JS, либо рисует страницу (CSS-анимации,
							render, reflow)</li>
					</ul>
				</section>
				<section>
					<h3>Пример с timeline работы браузера</h3>
					<img src="img/network-panel.png" alt="">
				</section>
				<section>
					<h3>Смягчающее действие</h3>
					<p class="text">Если событие обрабатывается слишком долго, то приложение в это время не имеет возможности обработать действия пользователя
						(например, скролл, или клик). Internet Explorer, в таком случае, выводит сообщение "A script on this page is causing
						Internet Explorer to run slowly"</p>
				</section>
				<section>
					<h3>Таймеры в js</h3>
					<blockquote>
						Таймеры - это не sleep(), они создают события, которые используют Event Loop
					</blockquote>
					<ul>
						<li>setTimeout(function, timeout) - не ранее чем через timeout</li>
						<li>setInterval(function, timeout) - не чаще чем через timeout</li>
						<li>Точность интервалов не гарантирована</li>
						<li>Если таймер содержит долгие вычисления <span class="highlight-blue">while (true) {i++;}</span>, то он задержит Event
							Loop
						</li>
					</ul>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs" data-trim="">
							var timeMark = new Date;
setTimeout(function go() {
    // выполнится через 100 мс
    var diff = new Date - timeMark;
    console.log(diff);
    timeMark = new Date; 
    setTimeout(go, 100); // снова в очередь
}, 100); //положили go() в очередь через 100 мс
//101
//100
//102
//101
//103
//100
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h3>Event Loop простыми словами</h3>
					<img src="img/Event-loop.png" alt="" height="500">
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Основан на событиях</li>
						<li>События складываются в очередь</li>
						<li>Ждем события, затем его выполняем</li>
						<li>События могут генерировать события</li>
						<li>Завершается при опустошении очереди</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Пример event loop</h2>
					<pre>
						<code class="hljs" data-trim>
$.get('/api/data.json', function(data) {
    getFile(data.filename, function() {
        alert('tada!');
    });
    showLoading('reading file');
});
showLoading('loading data');
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример event loop: Запрос к серверу</h3>
					<pre>
						<code class="hljs">
$.get('/api/data.json', function(data) {//выполняется
    getFile(data.filename, function() {
        alert('tada!');
    });
    showLoading('reading file');
});
showLoading('loading data');//выполняется
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример event loop: Ответ получен, функция читает файл</h3>
					<pre>
						<code class="hljs">
$.get('/api/data.json', function(data) {
    getFile(data.filename, function() {//выполняется
        alert('tada!');
    });
    showLoading('reading file');//выполняется
});
showLoading('loading data');
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример event loop: Файл прочитан</h3>
					<pre>
						<code class="hljs">
$.get('/api/data.json', function(data) {
    getFile(data.filename, function() {
        alert('tada!');//выполняется
    });
    showLoading('reading file');
});
showLoading('loading data')
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Плюсы и минусы</h2>
				<table>
					<thead>
						<tr>
							<th>+</th>
							<th>-</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td style="width: 50%;">отсутствие состояния "гонки"</td>
							<td>процессороемкие задачи блокируют работу event loop</td>
						</tr>
						<tr>
							<td>веб приложения тратят время на ожидание ввода-вывода</td>
							<td>выполняется на 1 ядре, а остальные 3 простаивают</td>
						</tr>
						<tr>
							<td>относительно проста для освоения</td>
							<td>утечки памяти</td>
						</tr>
					</tbody>
				</table>
			</section>
			<section>
				<h2>Если не хватает параллельности</h2>
			</section>
			<section>
				<h2>параллельное выполнение кода JavaScript</h2>
				<ul>
					<li>Dedicated workers (выделенные)</li>
					<li>SharedWorker (общие)</li>
				</ul>
			</section>
			</section>
			<section>
				<section>
					<h2>Dedicated workers</h2>
				</section>
				<section>
					<h2>Особенности</h2>
					<ul>
						<li>Объекты запускаются в изолированном потоке</li>
						<li>Выполняемый код должен храниться в отдельном файле</li>
						<li>Создается путем вызова конструктора</li>
						<li>Если указанный файл существует, то браузер создаст новый поток объекта Worker, загружаемый асинхронно</li>
					</ul>
				</section>
				<section>
					<h3>Алгоритм работы</h3>
					<pre>
						<code class="hljs">
var worker = new Worker('task.js');//инициализация
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
worker.postMessage(); //запуск
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
worker.postMessage('Hello World');//отправление сообщения воркеру
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
worker.terminate()//завершение работы
//или
this.close()// внутри объекта
						</code>
					</pre>
				</section>
				<section>
					<h3>Обмен сообщениями</h3>
					<p>Основной скрипт</p>
					<pre>
						<code class="hljs" data-trim>
							var worker = new Worker('doWork.js');

worker.addEventListener('message', function(e) {
  console.log('Worker said: ', e.data);
}, false);

worker.postMessage('Hello World'); // Send data to our worker.
						</code>
					</pre>
					<p>Второй скрипт</p>
					<pre>
						<code class="hljs" data-trim>
							self.addEventListener('message', function(e) {
  self.postMessage(e.data);
}, false);
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h3>SharedWorker</h3>
					<ul>
						<li>Создается путем вызова конструктора</li>
						<li>Идентифицируется по URL. Можно создать второй воркер из одного файла, добавив параметр в URL (worker.js?random=100)</li>
						<li>Работает с различными окнами, фреймами и файлами</li>
					</ul>
				</section>
				<section>
					<h3>Алгоритм работы</h3>
					<pre>
						<code class="hljs" data-trim>
var myWorker = new SharedWorker("worker.js");
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
myWorker.port.start();  //вызывается в главном потоке
port.start();  //вызывается в рабочем потоке
						</code>
					</pre>
				</section>
				<section>
					<h3>Передача сообщений</h3>
					<pre>
						<code class="hljs">
squareNumber.onchange = function() {
  myWorker.port.postMessage([squareNumber.value,squareNumber.value]);
  console.log('Message posted to worker');
}
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
self.addEventListener('connect', function(e) {
  var port = e.ports[0];
  port.onmessage = function(e) {
    var workerResult = 'Result: ' + (e.data[0] * e.data[1]);
    port.postMessage(workerResult);
  }
  port.start();
});
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
myWorker.port.onmessage = function(e) {
  result2.textContent = e.data[0];
  console.log('Message received from worker');
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Web Worke имеет доступ к:</h2>
				<ul>
					<li>Объект navigator</li>
					<li>Объект location (только чтение)</li>
					<li>XMLHttpRequest</li>
					<li>Таймеры (setTimeout/setInterval)</li>
					<li>Кэш приложений</li>
					<li>Импорт внешних скриптов (метод importScripts)</li>
					<li>Создание других объектов Web Worker</li>
				</ul>
			</section>
			<section>
				<h2>Web Worker не имеет доступа к:</h2>
				<ul>
					<li>Модель DOM</li>
					<li>Объект window</li>
					<li>Объект document</li>
					<li>Объект parent</li>
				</ul>
			</section>
			<section>
				<h2 class="header-hide">Спасибо за внимание</h2>
				<img src="img/thanks.jpg" alt="" height="600">
			</section>
		</div>
	</div>
	<aside id="presentable-icon" class="revealjs">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>