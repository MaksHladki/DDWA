<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>ECMAScript 5</title>
	<meta name="description" content="ECMAScript 5">
	<meta name="keywords" content="ECMAScript 5, строгий режим, наследование, ООП, события">
	<meta name="author" content="Maks Hladki">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="shortcut icon" href="../../img/js-icon.ico" type="image/x-icon">
	<link rel="stylesheet" href="../../css/bundle.min.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<section>
					<h1>Стандарт ECMAScript 5</h1>
					<h3>Разработка динамических веб приложений</h3>
					<p>
						<small>Гладкий Максим Валерьевич /
							<a href="https://github.com/MaksHladki/DDWA/">github:MaksHladki</a>
						</small>
					</p>
				</section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
			<section>
				<h1>Строгий режим</h1>
				<h3>(strict mode)</h3>
			</section>
			<section>
				<h2>Особенности</h2>
				<ul>
					<li>Более строгий вариант JavaScript</li>
					<li>Семантика, отличающаяся от обычно принятой</li>
					<li>Старые версии браузеров игнорируют строгий режим (
						<span class="highlight-blue">IE 9-</span>)</li>
					<li>Отменить действие use strict нельзя</li>
					<li>Применяется ко всему скрипту или к отдельным функциям</li>
					<li>Скрипт в строгом режиме + скрипт в обычном = скрипт в строгом режиме</li>
				</ul>
			</section>
			<section>
				<h2>Строгий режим для всего скрипта</h2>
				<pre>
					<code class="hljs javascript" data-trim>
"use strict";

myFunction();

function myFunction() {
    y = 3.14; 
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Строгий режим для функции</h2>
				<pre>
					<code class="hljs javascript" data-trim>      
var PI = 3.14;
myFunction();

function myFunction() {
   "use strict";
    var y = 3.14; 
}
					</code>
				</pre>
			</section>
			<section>
				<section>
					<h2>Правила игры</h2>
					<img data-src="img/batman-usescript.jpg">
				</section>
				<section>
					<h3>Дублирование ключей в объекте</h3>
					<p class="highlight-red">Удалено в спецификации ES2015</p>
					<pre>
						<code class="hljs javascript" data-trim>
var colors = {
    red: '#FF0000',
    green: '#00FF00',
    blue: '#0000FF',
    red: '#FF0000'
};
//Ex: An object literal cannot have multiple 
//properties with the same name in strict mode.
						</code>
					</pre>
				</section>
				<section>
					<h3>Объявление переменных без var</h3>
					<pre>
						<code class="hljs javascript" data-trim>
PI = 3.14;
//Ex: PI is not defined
						</code>
					</pre>
				</section>
				<section>
					<h3>Дублирование аргументов функции</h3>
					<pre>
						<code class="hljs javascript" data-trim>
function log(arg, arg) {
    console.log(arguments);
}
    
log(1, 2, 4);
//Ex: Duplicate parameter name not allowed in this context
						</code>
					</pre>
				</section>
				<section>
					<h3>Удаление "стандартных" свойств</h3>
					<pre>
						<code class="hljs javascript" data-trim>
delete Object.prototype; 
//Ex: Cannot delete property 'prototype' of function Object() 
						</code>
					</pre>
				</section>
				<section>
					<h3>Eval не добавляет новых переменных в окружающий контекст</h3>
					<pre>
						<code class="hljs javascript" data-trim>
var x = 17;
var evalX = eval("var x = 42;x");

console.log(x); //17
console.log(evalX); //42
						</code>
					</pre>
				</section>
				<section>
					<h3>Нельзя использовать with</h3>
					<pre>
						<code class="hljs javascript" data-trim>
var x = 17;
with (obj)
{
  x;
}
//Ex: syntax error
						</code>
					</pre>
				</section>
			</section>
			<!--Область видимости функций и замыкания-->
			<section>
				<h1>Область видимости функций и замыкания</h1>
			</section>
			<section>
				<section>
					<h2>Глобальный объект window</h2>
					<blockquote>
						В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «
						<span class="highlight-blue">глобальный объект
						</span>» (global object).
					</blockquote>
					<p class="text">
						В браузере этот объект доступен под именем
						<span class="highlight-blue">window</span>
					</p>
					<p class="text">
						Объект window одновременно является глобальным объектом и содержит ряд свойств и методов для работы с окном браузера.
					</p>
				</section>
				<section>
					<h3>Oбъект window: свойства и методы</h3>
					<img src="img/window.png" />
				</section>
				<section>
					<h3>Oбъект window: свойства и методы</h3>
					<img src="img/window_2.png" />
				</section>
				<section>
					<h3>Oбъект window: чтение/запись</h3>
					<pre>
						<code class="hljs javascript" data-trim>
var browser = 'Chrome';
console.log(window.browser); //Chrome

window.browser = 'Opera';
console.log(window.browser); //Opera
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Порядок выполнения JS-скрипта</h2>
					<ol>
						<li class="fragment">Инициализация, подготовка к запуску</li>
						<li class="fragment">Выполнение</li>
					</ol>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs javascript" data-trim>
//window = { f: function, log: undefined, browser: undefined }

var browser = 'Chrome';
//window = { f: function, log: undefined, browser: 'Chrome' }

var log = function (msg) {
    console.log(msg);
}
//window = { f: function, log: function, browser: 'Chrome' }

function f() {}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Свойства глобальной области видимости</h2>
					<ul>
						<li>Конструкции for, if... не влияют на видимость</li>
						<li>Повторное oбъявление переменных</li>
					</ul>
				</section>
				<section>
					<h3>for, while, if... не влияют на видимость</h3>
					<pre>
						<code class="hljs javascript" data-trim>
var N = 10;
var i;
for (i = 0; i < N; i++) {}

for (var i = 0; i < N; i++) {}
						</code>
					</pre>
				</section>
				<section>
					<h3>Повторное объявление переменных</h3>
					<pre>
						<code class="hljs javascript" data-trim> 
var i = 0;
while (i < N) {}

var i = 100;
var res = N * i;
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Лексическая область видимости</h2>
					<ul>
						<li>Функции имеют не динамическую, а лексическую область видимости</li>
						<li>Вложенная функция обладает возможностью доступа ко всем аргументам и локальным переменным объемлющей функции</li>
						<li>Все переменные внутри функции – это свойства специального внутреннего объекта
							<span class="highlight-blue">LexicalEnvironment</span>
						</li>
					</ul>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
					<code class="hljs javascript" data-trim>
function logger(msg) {
    //LexicalEnvironment = { msg: 'Test', date: undefined}
    var date = new Date().toDateString();
	
    //LexicalEnvironment = { msg: 'Test', date: 'Sun Oct 30 2016'}
    console.log(date + ' : ' + msg);
}

logger('Test');
					</code>
				</pre>
				</section>
				<section>
					<h3>Свойства LexicalEnvironment</h3>
					<ul>
						<li>Объект LexicalEnvironment является внутренним</li>
						<li>Объект скрыт от прямого доступа</li>
						<li>Интерпретатор сначала пытается найти переменную в текущем LE, а затем – во внешнем объекте переменных
						</li>
						<li>Cсылка на внешний объект переменных хранится в специальном внутреннем свойстве [[Scope]]</li>
						<li>При создании функция получает [[Scope]], которое ссылается на LE, в котором она создана</li>
					</ul>
					<pre>
					<code class="hljs javascript" data-trim>
logger.[[Scope]] = window;
					</code>
				</pre>
				</section>
			</section>
			<section>
				<h2>Как так-то</h2>
				<img src="img/vzryv-mozga.jpg">
			</section>
			<section>
				<h2>...простыми словами</h2>
				<ul>
					<li>Функция при создании получает ссылку [[Scope]] на объект с переменными, в контексте которого создана</li>
					<li>При запуске функции создаётся новый объект с переменными LexicalEnvironment</li>
					<li>При поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке</li>
					===
					<li class="highlight-blue">Функция читает переменные снаружи</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Доступ к внешним переменным</h2>
					<pre>
						<code class="hljs javascript" data-trim>
var date = new Date().toDateString();

function logger(msg) {
    //LexicalEnvironment = { msg: 'Test', date: 'Sun Oct 30 2016'}
    console.log(date + ' : ' + msg);
}

logger('Test');
						</code>
					</pre>
				</section>
				<section>
					<h3>Всегда текущее значение</h3>
					<pre>
						<code class="hljs javascript" data-trim>
var date = new Date().toDateString();

function logger(msg) {
    console.log(date + ' : ' + msg);
}

logger('Test'); //Sun Oct 30 2016 : Test

date = '30.10.2016';

logger('Test 2'); //30.10.2016 : Test 2
					</code>
					</pre>
				</section>
				<section>
					<h3>Немного усложним</h3>
					<pre>
						<code class="hljs javascript" data-trim>
function makeCounter() {
    var currentCount = 1;

    return function () {
        return currentCount++;
    };
}

var counter = makeCounter();

//каждый вызов увеличивает счётчик и возвращает результат
console.log(counter()); //1
console.log(counter()); //2
console.log(counter()); //3

//если создать другой счётчик, он будет независим от первого
var counter2 = makeCounter();
console.log(counter2()); //1
						</code>
					</pre>
				</section>
				<section>
					<h3>new Function</h3>
					<pre>
						<code class="hljs javascript" data-trim>
window.a = 1;

function getFunc() {
  var a = 2;
  var func = new Function('', 'alert(a)'); 
  return func;
}
 
getFunc()();//1
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Итого</h2>
				<blockquote>
					Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны
				</blockquote>
				<ul>
					<li>Значение переменной из внешней области берется всегда текущее</li>
					<li>Переменную во внешней области видимости можно не только читать, но и изменять</li>
					<li>При создании функции с использованием new Function, [[Scope]] ссылается на window</li>
				</ul>
			</section>
			<!-- End Замыкания-->
			<section>
				<h2>Проверка знаний</h2>
				<pre>
					<code class="hljs javascript" data-trim>
var counter = 5;

var add = (function () {
    var counter = 0;
    return function () {
        return counter += 1;
    }
})();

add();
add();

console.log(add());//???
						</code>
				</pre>
				<p class="fragment">counter = 3</p>
			</section>
			<section>
				<h1>this</h1>
			</section>
			<section>
				<section>
					<h2>Доступ к текущему объекту из метода</h2>
					<pre>
						<code class="hljs javascript" data-trim>
var student1 = {
    course: 3,
    print: function(){
        console.log(course);
    }
};

student1.print();
//Ex: Uncaught ReferenceError: course is not defined

var student2 = {
    name: 'Max',
    print: function(){
        console.log(this.name);
    }
};

student2.print();//Max
							</code>
					</pre>
				</section>
				<section>
					<h3>Обращение к объекту по имени переменной</h3>
					<pre>
						<code class="hljs javascript" data-trim>
var student2 = {
    name: 'Max',
    print: function(){
        console.log(student2.name);
    }
};

student2.print();//Max
							</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Особенности this</h2>
				</section>
				<section>
					<h3>Любая функция может иметь в себе this</h3>
					<pre>
						<code class="hljs javascript" data-trim>
function func(){ 
    console.log(this); 
} 

func();//[object Window]
						</code>
					</pre>
				</section>
				<section>
					<h3>Разный контекст</h3>
					<small>
						<blockquote>
							Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный this. Это значение не зависит
							от того, как функция была создана, оно определяется в момент вызова
						</blockquote>
					</small>
					<pre>
						<code class="hljs javascript" data-trim>
function print (){
    console.log(this.name);
}

var person = {
    name: 'Irina',
    print: print
};

var student = {
    name: 'Ivan',
    print: print
};

person.print();//Irina
student.print();//Ivan
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Явное указание и привязка контекста</h2>
				<ul>
					<li>Call</li>
					<li>Apply</li>
					<li>Bind</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Метод Call</h2>
					<p>Вызывает функцию с указанным значением this и предоставленными аргументами</p>
					<pre>
						<code class="hljs javascript" data-trim>
fun.call(thisArg[, arg1[, arg2[, ...]]])
					</code>
					</pre>
				</section>
				<section>
					<h3>
						Пример
					</h3>
					<pre>
						<code class="hljs javascript" data-trim>
function showFullName() {
    console.log(this.firstName + " " + this.lastName);
}

var user = {
    firstName: "Василий",
    lastName: "Петров"
};

//this = user
showFullName.call(user);//Василий Петров
				</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Метод Apply</h2>
					<p>Вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива</p>
					<pre>
						<code class="hljs javascript" data-trim>
func.apply(context, [argsArray])
					</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs javascript" data-trim>
var x = 10;
var o = { x: 15 };

function f(message)
{
    console.log(message);
    console.log(this.x);
}
 
f("test");//test 10
f.apply(o, ["test"]);//test 15
					</code>
				</pre>
				</section>
				<section>
					<h3>Использование со встроенными функциями</h3>
					<pre><code class="hljs javascript" data-trim>
/* мин/макс числа в массиве */
var numbers = [5, 6, 2, 3, 7];

/* используем apply к Math.min/Math.max */
var max = Math.max.apply(null, numbers); 

/* Это эквивалентно Math.max(numbers[0], ...)
или Math.max(5, 6, ...) */

var min = Math.min.apply(null, numbers);	
		</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Метод Bind</h2>
					<ul>
						<li>Cоздаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение
						</li>
						<li>Bind не вызывает функцию, он только возвращает «обертку»</li>
					</ul>
					<pre>
						<code class="hljs javascript"data-trim>
var wrapper = func.bind(context[, arg1, arg2...])
					</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre><code class="hljs javascript" data-trim>
function f(a, b) {
  console.log(this);
  console.log(a + b);
}

var g = f.bind("Context");
g(1, 2); //Context 3
		</code></pre>
				</section>
			</section>
			<section>
				<h2>
					Карринг (currying) параметров
				</h2>
				<blockquote>
					Создание новой функции путем фиксирования аргументов существующей (термин из функционального программирования)
				</blockquote>
				<pre>
					<code class="hljs javascript" data-trim>
function mul(a, b) {
    return a * b;
}

//double умножает только на два
var double = mul.bind(null, 2); 
//контекст фиксируем null, он не используется

console.log(double(3));//mul(2, 3) = 6
console.log(double(4));//mul(2, 4) = 8
console.log(double(5));//mul(2, 5) = 10
					</code>
				</pre>
			</section>
			<section>
				<h2>Одалживание метода</h2>
				<pre>
					<code class="hljs javascript" data-trim>
function showArgs() {
    //arguments.length [0] ... [n]

    var argStr = arguments.join(':');
    console.log(argStr); 
}

showArgs(1, 2, 3);//arguments.join is not a function(…)
	</code>
				</pre>
				<pre>
					<code class="hljs javascript" data-trim>
function showArgs() {
    var join = [].join; //скопируем ссылку на функцию в переменную
    //вызовем join с this = arguments,
    //этот вызов эквивалентен arguments.join(':')
	
    var argStr = join.call(arguments, ':');
    console.log(argStr);
}

showArgs(1, 2, 3);//1:2:3
					</code>
				</pre>
			</section>
			<!--Start ООП в JavaScript -->
			<section>
				<h1>ООП в JavaScript</h1>
				<ul>
					<li>ООП в функциональном стиле</li>
					<li>ООП в прототипном стиле</li>
				</ul>
			</section>
			<section>
				<h2>Стандартные объекты</h2>
				<small>
					<table>
						<tbody>
							<tr>
								<td>Array</td>
								<td>массив пронумерованных элементов</td>
							</tr>
							<tr>
								<td>Boolean</td>
								<td>объект для булевых значений</td>
							</tr>
							<tr>
								<td>Date</td>
								<td>функции для работы с датой и временем</td>
							</tr>
							<tr>
								<td>Error</td>
								<td>объект для представления ошибок</td>
							</tr>
							<tr>
								<td>Function</td>
								<td>каждая функция в JS является объектом класса Function</td>
							</tr>
							<tr>
								<td>JSON</td>
								<td>содержит методы для разбора объектной нотации JS</td>
							</tr>
							<tr>
								<td>Math</td>
								<td>константы и методы для математических вычислений</td>
							</tr>
							<tr>
								<td>Number</td>
								<td>объект для работы с числами</td>
							</tr>
							<tr>
								<td>Object</td>
								<td>базовый объект javascript</td>
							</tr>
							<tr>
								<td>RegExp</td>
								<td>позволяет работать с регулярными выражениями.</td>
							</tr>
							<tr>
								<td>String</td>
								<td>управление, форматирование и другие операции с текстовыми строками</td>
							</tr>
							<tr>
								<td>SyntaxError</td>
								<td>ошибка при интерпретации синтаксически неверного кода</td>
							</tr>
							<tr>
								<td>window</td>
								<td>определяет глобальный объект и окно браузера</td>
							</tr>
						</tbody>
					</table>
				</small>
			</section>
			<section>
				<h1>ОПП в функциональном стиле</h1>
			</section>
			<section>
				<section>
					<h2>Определение конструктора</h2>
					<pre>
						<code class="hljs javascript" data-trim>
function Person(name, age){
    this.name = name;
    this.age = age;

    this.getName = function(){
        return this.name;
    }
	
    this.getAge = function(){
        return this.age;
    }
}
					</code>
					</pre>
				</section>
				<section>
					<h3>Пример создания экземпляра</h3>
					<pre>
						<code class="hljs javascript" data-trim>
var person = new Person('Max', 18);
console.log(person.getName());//Max
console.log(person.getAge()); //18

console.log(person instanceof Object);//true
console.log(person instanceof Person);//true
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>
					Особенности
				</h2>
				<ul>
					<li>Имена конструкторов обычно начинаются с прописной буквы</li>
					<li>Объект явно не создается</li>
					<li>Свойства и метод назначаются непосредственно объекту this</li>
					<li>Для создания экземпляров используется оператор new</li>
					<li>Инструкция return отсутствует</li>
				</ul>
			</section>
			<section>
				<h2>Порядок создания экземпляра</h2>
				<ol>
					<li class="fragment">Создание объекта</li>
					<li class="fragment">Назначение нового объекта переменной this конструктора (после чего this указывает на новый объект)</li>
					<li class="fragment">Выполнение кода внутри конструктора (добавление свойств к новому объекту)</li>
					<li class="fragment">Возвращение нового объекта</li>
				</ol>
			</section>
			<section>
				<section>
					<h2>Проблемы конструкторов</h2>
					<img src="img/hproblem.jpg">
				</section>
				<section>
					<h3>Методы создаются для каждого экземпляра</h3>
					<pre>
						<code class="hljs javascript" data-trim>
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.getName = new Function('return this.name;');
}

var p1 = new Person('Ira', 23);
var p2 = new Person('Max', 25);

console.log(p1.getName());//Ira
console.log(p2.getName());//Max
console.log(p1.getName == p2.getName); //false

						</code>
					</pre>
				</section>
				<section>
					<h3>Методы создаются для каждого экземпляра</h3>
					<pre>
						<code class="hljs javascript" data-trim>
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.getName = function() {
        return this.name;
    }
}

var p1 = new Person('Ira', 23);
var p2 = new Person('Max', 25);

console.log(p1.getName()); //Ira
console.log(p2.getName()); //Max
console.log(p1.getName == p2.getName); //false
						</code>
					</pre>
				</section>
				<section>
					<h3>Hot Fix</h3>
					<pre>
						<code class="hljs javascript" data-trim>
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.getName = getName
}

function getName(){
    return this.name;
}

var p1 = new Person('Ira', 23);
var p2 = new Person('Max', 25);
console.log(p1.getName == p2.getName); //true
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Внутренний и внешний интерфейс</h2>
					<p>Публичное и приватное свойство</p>
					<pre>
						<code class="hljs javascript" data-trim>
function Person(name, age) {
    var fAge = 'лет';
    this.name = name;
    this.getAge = function(){
        return age + ' ' + fAge;
    }
}

var person = new Person('Max', 20);
person.name = 'Maxim';

console.log(person.name);//Maxim
console.log(person.getAge());//20 лет	
					</code>
						<pre>
				</section>
				<section>
					<h3>Внутренний и внешний интерфейс</h3>
					<p>Публичный и приватный метод</p>
					<pre>
						<code class="hljs javascript" data-trim>
function Person(name, age) {
    this.name = name;
    this.getAge = function(){
        return formatAge(age);
    }

    function formatAge(age){
        return age + ' лет';
    }
}

var person = new Person('Max', 20);

console.log(person.formatAge);//undefined
console.log(person.getAge());//20 лет
					</code>
						<pre>
				</section>
			</section>
			<section>
				<h2>Геттеры и сеттеры</h2>
				<pre>
					<code class="hljs javascript" data-trim>
function Person() {
    var _age = 0;
    this.setAge = function (age) {
        if (age <= 0 || age >= 100)
            throw "Значение должно быть больше 0 и меньше 100";

        _age = age;
    }
    this.getAge = function () {
        return _age;
    }
}

var person = new Person();
person.setAge(20);

console.log(person.getAge());//20 
person.setAge(100);//Ex. Значение должно быть больше 0 и меньше 100
					</code>
				</pre>
				</section>
				<section>
					<section>
						<h2>Наследование</h2>
						<pre>
						<code class="hljs javascript" data-trim>
							
function Person(name, age){
    this.name = name;
    this.age = age;
    this.getName = function(){
        return this.name;
    }
    this.getAge = function(){
        return this.age;
    }
}

					</code>
					</pre>
					</section>
					<section>
						<h3>Расширяем</h3>
						<pre>
						<code class="hljs javascript" data-trim>
function Student(course, group) {
    Person.call(this);
	
    this.course = course;
    this.group = group;
}

var student = new Student(1, 1);
student.name = 'Peter';
student.age = 24;

console.log(student.name);//Peter
console.log(student.group);//1
						</code>
					</pre>
						<p class="highlight-blue"> Person.call(this);</p>
					</section>
					<section>
						<h3>Переопределение метода</h3>
						<pre>
						<code class="hljs javascript" data-trim>		
function Student(course, group) {
    Person.call(this);
	
    this.course = course;
    this.group = group;

    this.getAge = function () {
        return this.age + ' лет';
    }
}

var student = new Student(1, 1);
student.age = 20;

console.log(student.getAge()); //20 лет
						</code>
					</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Сохранение this в замыкании</h2>
						<pre>
						<code class="hljs javascript" data-trim>
function Person(name, age) {
    this.age = age;
    this.printAge = function () {
        setTimeout(console.log(formatAge()), 1000);
    }

    function formatAge() {
        return this.age + ' лет';
    }
}

var person = new Person('Max', 20);
person.printAge(); //undefined лет
						</code>
					</pre>
					</section>
					<section>
						<h3>Сохранение this в замыкании</h3>
						<pre>
						<code class="hljs javascript" data-trim>
function Person(name, age) {
   var self = this;
   this.age = age;
   this.printAge = function(){
       setTimeout(console.log(formatAge()), 1000);
   }
   function formatAge(){
       return self.age + ' лет';
   }
}

var person = new Person('Max', 20);
person.printAge(); //20 лет
					</code>
					</pre>
					</section>
					<section>
						<h3>Запомним</h3>
						<blockquote>
							<b>
								<span class="highlight-blue">THIS</span>
							</b> в JS не привязывается к объекту, а зависит от контекста вызова. В случае с конструктором
							<span class="highlight-blue">this</span> ссылается на созданный экземпляр при условии использования ключевого слова new.
						</blockquote>
					</section>
				</section>
				<section>
					<h2>Статические члены</h2>
					<pre>
						<code class="hljs javascript" data-trim>
function Person(name, age){
    this.name = name;
    this.age = age;
    this.getName = function(){
        return this.name;
    }
    this.getAge = function(){
        return this.age;
    }
    Person.counter++;
}

Person.counter = 0;
Person.getCount = function(){
    return Person.counter;
}

new Person('Max', 26);
new Person('Yulia', 21);
console.log(Person.getCount());//2
						</code>
					</pre>
				</section>
				<section>
					<h1>ООП в прототипном стиле</h1>
				</section>
				<section>
					<section>
						<h2>Прототип Proto</h2>
						<pre>
						<code class="hljs javascript" data-trim>				
var person = {
    age: 24,
    name: 'Alex'
};

var student = {
    course: 1,
    group: 6
};

student.__proto__ = person;

console.log(student.age);//24
console.log(student.name);//Alex
					</code>
					</pre>
					</section>
					<section>
						<h3>Схема</h3>
						<img src="img/proto.png" />
					</section>
				</section>
				<section>
					<h2>Особенности</h2>
					<ul>
						<li>Объекты можно организовать в цепочки (свойство, не найденное в одном объекте, автоматически ищется в другом)</li>
						<li>Свойство __proto__ доступно во всех браузерах, кроме IE10-</li>
						<li>Объект, на который указывает ссылка __proto__, называется «прототипом»</li>
						<li>Все объекты, созданные объектными литералами, имеют прототип Object.prototype</li>
						<li>Объекты, созданные с помощью new и конструктора, имеют в качестве прототипа значение свойства prototype
						</li>
						<li>Прототип используется только при чтении</li>
					</ul>
				</section>
				<section>
					<h2>Proto: read only</h2>
					<pre>
					<code class="hljs javascript" data-trim>	
var person = {
    age: 24,
    name: 'Alex'
};

var student = {
    course: 1,
    group: 6
};

student.__proto__ = person;
student.age = 10;

console.log(student.age);//10
console.log(person.age);//24

delete student.age;
console.log(person.age);//24
console.log(student.age);//24
					</code>
				</pre>
				</section>
				<section>
					<h2>Свойство prototype</h2>
					<ul>
						<li>Имеет смысл только у конструктора</li>
						<li>Объекты обычно создаются функцией-конструктором через new</li>
						<li>__proto__ не работает в IE10-</li>
					</ul>
					<pre>
					<code class="hljs javascript" data-trim>
var person = {
    age: 24,
    name: 'Alex'
};

function Student(course, group) {
    this.course = course,
    this.group = group;
    //this.__proto__ = person; не работает в IE10-
};

//!!! свойство доступно через тип, а не через объект
Student.prototype = person;
var student = new Student(1, 1);
console.log(student.age);//24
				</code>
				</pre>
				</section>
				<section>
					<h2>Добавление метода через прототип</h2>
					<pre>
					<code class="hljs javascript" data-trim>
function Person(age, name){
    this.Age = age;
    this.Name = name;
}

Person.prototype.getAge = function(){
    return this.Age;
}

var person = new Person(20, 'Max');
console.log(person.getAge());//20

var person2 = new Person(18, 'Yulia');
console.log(person.getAge == person2.getAge);//true
					</code>
				</pre>
				</section>
				<section>
					<h1>Класс Object</h1>
				</section>
				<section>
					<section>
						<h2>Конструктор</h2>
						<ul>
							<li>Object.length имеет значение 1</li>
							<li>Object.prototype позволяет добавлять свойства ко всем объектам типа Object</li>
						</ul>
						<pre>
						<code class="hljs javascript" data-trim>
var o1 = new Object();
console.log(o1);//{}

var o2 = {};
console.log(o2);//{}
				</code>
					</pre>
					</section>
					<section>
						<h3>Класс Object в разрезе</h3>
						<img src="img/object.png">
						<p>Объект Object.prototype – вершина иерархии, единственный, у которого
							<span class="highlight-blue">__proto__ равно null</span>
						</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Метод create</h2>
						<blockquote>
							Cоздает новый объект с указанными объектом прототипа и свойствами
						</blockquote>
						<pre>
					<code class="hljs javascript" data-trim>
Object.create(proto[, propertiesObject])
					</code>
				</pre>
						<pre>
					<code class="hljs javascript" data-trim>
var person = {
    age: 20
}

var student = Object.create(person);
console.log(student.age);//20
					</code>
				</pre>
					</section>
					<section>
						<h3>Пример наследования</h3>
						<pre>
					<code class="hljs javascript" data-trim>
function Person(name) {
    this.name = name;
}
						
function Student(course, name) {
    Person.call(this, name);
    this.course = course;
}
						 
Student.prototype = Object.create(Person.prototype);
				
var student = new Student(5, 'Anna');
console.log(student.name);//Anna
console.log(student.course);//5
					</code>
				</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Свойство prototype</h2>
						<pre>
					<code class="hljs javascript" data-trim>
function Person(){
    this.age = 0;
}

Person.prototype.setAge = function(age){
    this.age = age;
}

Person.prototype.getAge = function(){
    return this.age;
}

var person = new Person();
person.setAge(100);

console.log(person.getAge());//100
					</code>
				</pre>
					</section>
					<section>
						<h3>Наследование</h3>
						<pre>
					<code class="hljs javascript" data-trim>
function Person(name) {
    this.name = name;
}
Person.prototype.setName = function (name) {
    this.name = name;
}
Person.prototype.getName = function () {
    return this.name;
}
function Student(course, name) {
    Person.call(this, name);
    this.course = course;
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.getCourse = function () {
    return this.course;
}
var student = new Student(10, 'Anna');
console.log(student.getName());//Anna
				</code>
				</pre>
					</section>
					<section>
						<h3>Вызов метода родителя</h3>
						<pre>
					<code class="hljs javascript" data-trim>
function Person(name) {
    this.name = name;
}
Person.prototype.setName = function (name) {
    this.name = name;
}
Person.prototype.getName = function () {
    return this.name;
}
function Student(name) {
    Person.call(this, name);
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.getName = function () {
    return 'Name: ' + Person.prototype.getName.call(this);
}

var student = new Student('Anna');
console.log(student.getName());//Name: Anna  
				</code>
				</pre>
					</section>
				</section>
				<section>
					<h2>Метод toString</h2>
					<pre>
					<code class="hljs javascript" data-trim>
function Person(){
    this.age = 0;
}
var person = new Person();
alert(person);//[object Object]

Person.prototype.toString = function(){
    return this.age;
}

alert(person);//0
					</code>
				</pre>
				</section>
				<section>
					<section>
						<h2>Метод hasOwnProperty</h2>
						<pre>
						<code class="hljs javascript" data-trim>
//Вывод ключей без использования метода hasOwnProperty
var person = {
    age: 24,
    name: 'Alex'
};

var student = {
    course: 1,
    group: 6
};

student.__proto__ = person;

for(var key in student)//course group name age
    console.log(key);
					</code>
					</pre>
					</section>
					<section>
						<h3>С использованием hasOwnProperty</h3>
						<pre>
						<code class="hljs javascript" data-trim>
//Вывод ключей с использованием метода hasOwnProperty
var person = {
    age: 24,
    name: 'Alex'
};

var student = {
    course: 1,
    group: 6
};

student.__proto__ = person;

for(var key in student)//course group
   if(student.hasOwnProperty(key)) console.log(key);
					</code>
					</pre>
					</section>
				</section>
				<section>
					<h2>Метод keys</h2>
					<pre>
					<code class="hljs javascript" data-trim>
function Person(name) {
    this.name = name;
}

Person.prototype.setName = function (name) {
    this.name = name;
}

Person.prototype.getName = function () {
    return this.name;
}

function Student(course) {
    this.course = course;
}

Student.prototype = Object.create(Person.prototype);
var student = new Student(20);
console.log(Object.keys(student));//["course"]
					</code>
				</pre>
				</section>
				<section>
					<section>
						<h2>Метод defineProperty</h2>
						<pre>
						<code class="hljs javascript" data-trim>
function Person(name) {
    this.name = name;
}
var person = new Person(20);

Object.defineProperty(person, 'age', {
    enumerable: true,
    configurable: true,
    //writable: true, нельзя использовать совместно с get/set
    //value: 0, нельзя использовать совместно с get/set
    get: function(){
        return age + ' лет';
    },
    set: function(newAge){
        age = newAge;
    }
});

person.age = 10;
console.log(person.age);//10 лет
					</code>
					</pre>
					</section>
					<section>
						<h3>Еще один пример</h3>
						<pre>
						<code class="hljs javascript" data-trim>
function Person(name) {
    this.name = name;
    Object.defineProperty(this, 'age', {
        enumerable: false,
        configurable: true,
        value: 0,
    });
}

var person = new Person(20);

console.log(Object.getOwnPropertyNames(person));//["name", "age"]
console.log(Object.keys(person));//["name"]
					</code>
					</pre>
					</section>
				</section>
				<section>
					<h2>Изменение встроенных прототипов</h2>
					<pre>
					<code class="hljs javascript" data-trim>
function Person(){
     this.age = 0;
}

var person = new Person();
alert(person);//[object Object]

Person.prototype.toString = function(){
     return this.age;
}

alert(person);//0
					</code>
				</pre>
				</section>
				<section>
					<section>
						<h2>Операторы проверки типов</h2>
						<ul>
							<li>typeof</li>
							<li>instanceof</li>
						</ul>
					</section>
					<section>
						<h3>Оператор typeof</h3>
						<pre>
						<code class="hljs javascript" data-trim>
function A(){}
function B(){}

B.prototype = Object.create(A.prototype);

console.log(typeof undefined);//undefined
console.log(typeof 0);//number
console.log(typeof true );//boolean
console.log(typeof "foo"); //string
console.log(typeof {}); //object
console.log(typeof null); //object
console.log(typeof function(){}); //function

var a = new A();
console.log(typeof a);//object

var b = new B();
console.log(typeof b);//object
						</code>
					</pre>
					</section>
					<section>
						<h3>Оператор instanceof</h3>
						<pre>
						<code class="hljs javascript" data-trim>
function A(){}
function B(){}

B.prototype = Object.create(A.prototype);

var a = new A();
var b = new B();

console.log(a instanceof A);//true
console.log(b instanceof B);//true
console.log(a instanceof B);//false
console.log(b instanceof A);//true
console.log(a instanceof Object);//true
console.log(b instanceof Object);//true

console.log(A.prototype instanceof Object);//true
console.log(B.prototype instanceof Object);//true
console.log(A.prototype instanceof B);//false
console.log(B.prototype instanceof A);//true
console.log(Object.prototype instanceof Object);//false
						</code>
					</pre>
					</section>
				</section>
				<!-- Объектная модель документа -->
				<section>
					<h1>
						Объектная модель документа
					</h1>
				</section>
				<section>
					<h2>Структура браузерных объектов</h2>
					<img src="img/window.environment.png" alt="">
				</section>
				<section>
					<section>
						<h2>Пример DOM-дерева</h2>
						<pre>
						<code class="hljs html" data-trim>
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Какой-то заголовок&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  Какой-то текст
&lt;/body&gt;
&lt;/html&gt;
						</code>
					</pre>
					</section>
					<section>
						<h3>Вид документа</h3>
						<img src="img/dom-view.png">
					</section>
					<section>
						<h3>Типы узлов в примере</h3>
						<ol>
							<li>Теги образуют узлы-элементы (element node). Одни узлы могут быть вложены в другие. Дерево образуется исключительно
								за счет них</li>
							<li>Текст внутри элементов образует текстовые узлы (text node, #text). Текстовый узел содержит исключительно строку текста
								и не может иметь потомков, то есть он всегда на самом нижнем уровне</li>
						</ol>
						<blockquote>
							Пробелы и переводы строки – это тоже текст, полноправные символы, которые учитываются в DOM
						</blockquote>
					</section>
				</section>
				<section>
					<h2>Типы узлов (w3.org)</h2>
					<pre>
					<code class="hljs javascript" data-trim>
interface Node {
  //Всевозможные значения nodeType
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2;
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4;
  const unsigned short ENTITY_REFERENCE_NODE = 5;
  const unsigned short ENTITY_NODE = 6;
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12;
  ...
}
					</code>
				</pre>
				</section>
				<section>
					<section>
						<h2>HTMLCollection</h2>
						<blockquote>
							Интерфейс HTMLCollection является обобщённой коллекцией (объектом, ведущим себя подобно массиву) элементов (в порядке упоминания
							в документе) и предоставляет методы и свойства для получения хранящихся в нём элементов
						</blockquote>
					</section>
					<section>
						<h3>Методы HTMLCollection</h3>
						<table>
							<tr>
								<td>item</td>
								<td>возвращает узел с порядковым номером index; отсчёт ведётся от нуля. Возвращает null, если index выходит за границы
									допустимого диапазона</td>
							</tr>
							<tr>
								<td>namedItem</td>
								<td>возвращает узел, идентификатор или имя которого совпадает со строкой, переданной в аргументе name. Возвращает null,
									если элемент отсутствует</td>
							</tr>
						</table>
					</section>
					<section>
						<h3>Свойства HTMLCollection</h3>
						<table>
							<tr>
								<td>length</td>
								<td>возвращает количество элементов в коллекции</td>
							</tr>
						</table>
					</section>
					<section>
						<h3>HTMLCollection - живые коллекции</h3>
						<pre>
						<code class="hljs javascript" data-trim>
var images = document.images;
console.log(images.length);//1

var img = document.createElement('img');
document.body.appendChild(img);

console.log(images.length);//2
						</code>
					</pre>
					</section>
					<section>
						<h3>Расширяем горизонты (forEach для HtmlCollection)</h3>
						<pre>
						<code class="hljs javascript" data-trim>
function foreach(){
    var collections = document.body.childNodes;
	
    [].forEach.call(collections, function(item, index){
        console.log(item);
        console.log(index);
    });
}
						</code>
					</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Навигация по DOM-элементам</h2>
						<img src="img/dom-links.png" alt="" height="500">
					</section>
					<section>
						<h3>Пример</h3>
						<pre>
							<code class="hljs html" data-trim>
&lt;!DOCTYPE&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Navigation&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="container"&gt;
        &lt;div class="content" name="content"&gt;
            &lt;div class="title"&gt;
                &lt;h3 name="title_1"&gt;Title 1&lt;/h3&gt;
            &lt;/div&gt;
            &lt;div class="message"&gt;
                &lt;a href="google.com"&gt;google&lt;/a&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;div class="title"&gt;
                &lt;h3&gt;Title 2&lt;/h3&gt;
            &lt;/div&gt;
            &lt;div class="message"&gt;
                &lt;img src="https://www.wired.com/wp-content/uploads/2015/09/google-logo-1200x630.jpg" alt=""&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="navigation.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var example = new NavigationExample();
        example.title();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
							</code>
						</pre>
					</section>
					<section>
						<h3>document.body</h3>
						<p>Запись запрещена, только чтение</p>
						<img src="img/document-body.png" alt="">
					</section>
					<section>
						<h3>document.head</h3>
						<img src="img/document-head.png" alt="">
						<p>Только getter, запись без сохранения результата</p>
						<pre>
						<code class="hljs javascript" data-trim>			
function head() {
    console.log(document.head);
    document.head = '<h1>Test</h1>';
    console.log(document.head);
}
						</code>
					</pre>
					</section>
					<section>
						<h3>document.title</h3>
						<img src="img/document-head.png" alt="">
						<p>Getter + Setter</p>
						<pre>
						<code class="hljs javascript" data-trim>		
    function title() {
        console.log(document.title);//Navigation
        document.title = 'Test';
        console.log(document.title);//Test
    }
						</code>
					</pre>
					</section>
					<section>
						<h3>document.links</h3>
						<img src="img/document-links.png" alt="">
						<p>Только getter, запись без сохранения результата</p>
						<pre>
						<code class="hljs javascript" data-trim>		
function links(){
    console.log(document.links);
    document.links = [];
    console.log(document.links);
}
						</code>
					</pre>
					</section>
					<section>
						<h3>document.images</h3>
						<img src="img/document-images.png" alt="">
						<p>Только getter, запись без сохранения результата</p>
						<pre>
						<code class="hljs javascript" data-trim>		
function images(){
    console.log(document.images);
    document.images = [];
    console.log(document.images);
}
						</code>
					</pre>
					</section>
					<section>
						<h3>document.documentElement</h3>
						<img src="img/document-documentelement.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>		
console.log(document.documentElement);
//root element in document (html)
					</code>
					</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Элементы DOM-дерева</h2>
						<p class="text">
							<span class="highlight-blue">Дочерние элементы (дети)</span> – элементы, которые лежат непосредственно внутри данного. Например, внутри &lt;HTML&gt;
							обычно лежат &lt;HEAD&gt; и &lt;BODY&gt;</p>
						<p class="text">
							<span class="highlight-blue">Потомки</span> – все элементы, которые лежат внутри данного, вместе с их детьми, детьми их детей и так далее. То есть,
							всё поддерево DOM</p>
					</section>
					<section>
						<h2>Дочерние элементы</h2>
						<ul>
							<li>DOM-коллекции (HTMLCollection) не являются JavaScript-массивами. В них нет методов forEach, map, push, pop и т.д.</li>
							<li>Нельзя перебирать коллекцию через for..in</li>
							<li>В качестве значения, обозначающего «нет такого элемента» или «узел не найден», используется не undefined, а
								<span class="highlight-blue">null</span>
							</li>
						</ul>
					</section>
					<section>
						<h3>Свойство Node.childNodes</h3>
						<img src="img/childnodes1.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
 console.log(document.body.childNodes);
						</code>
					</pre>
					</section>
					<section>
						<h3>Свойство Node.childNodes</h3>
						<img src="img/childnodes2.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
 console.log(document.body.childNodes[1].childNodes);
						</code>
					</pre>
					</section>
					<section>
						<h3>Свойство Node.childNodes</h3>
						<img src="img/childnodes2.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
for (var i = 0; i < document.body.childNodes.length; i++) {
      console.log( document.body.childNodes[i] ); 
}

var container = document.getElementById('container');
for (var i = 0; i < container.childNodes.length; i++) {
      console.log( document.body.childNodes[i] ); 
}
						</code>
					</pre>
					</section>
					<section>
						<h3>Свойство Node.firstChild</h3>
						<ul>
							<li>Свойство только для чтения</li>
							<li>Возвращающее первый потомок узла в древе или null, если узел является бездетным</li>
							<li>Если узел это документ, он возвращает первый узел в списке своих прямых детей</li>
						</ul>
					</section>
					<section>
						<h3>Свойство Node.firstChild</h3>
						<img src="img/document-firstchild.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
function firstChild() {
    console.log(document.body.firstChild);
    console.log(document.body.childNodes.firstChild);
    console.log(document.body.childNodes[1].firstChild);
}
						</code>
					</pre>
					</section>
					<section>
						<h3>Свойство Node.lastChild</h3>
						<img src="img/document-lastchild.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
function firstChild() {
    console.log(document.body.lastChild);
    console.log(document.body.childNodes.lastChild);
    console.log(document.body.childNodes[1].lastChild);
}
						</code>
					</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Соседние элементы и родительский элемент</h2>
						<ul>
							<li>children – только дочерние узлы-элементы, то есть соответствующие тегам</li>
							<li>firstElementChild, lastElementChild – соответственно, первый и последний дети-элементы</li>
							<li>previousElementSibling, nextElementSibling – соседи-элементы</li>
							<li>parentElement – родитель-элемент</li>
						</ul>
					</section>
					<section>
						<h3>Свойство children</h3>
						<p>В отличии от childNodes, children удаляет текстовые узлы и комментарии</p>
						<img src="img/children.png" alt="" height="250">
						<pre>
						<code class="hljs javascript" data-trim>
function children(){
    console.log(document.body.children);
    console.log(document.body.children[0].children);
}
						</code>
					</pre>
					</section>
					<section>
						<h3>firstElementChild</h3>
						<p>Доступное только для чтения свойство, возвращает первый дочерний элемент объекта (Element) или null, если дочерних
							элементов нет</p>
						<img src="img/firstElementChild.png" alt="">
						<pre><code class="hljs javascript" data-trim>  
function firstElementChild(){
    console.log(document.body.firstElementChild);
    console.log(document.body.childNodes.firstElementChild);
    console.log(document.body.childNodes[1].firstElementChild);
}

	</code></pre>
					</section>
					<section>
						<h3>lastElementChild</h3>
						<p>Доступное только для чтения свойство, возвращает первый дочерний элемент объекта (Element) или null, если дочерних
							элементов нет</p>
						<img src="img/lastelementchild.png" alt="">
						<pre><code class="hljs javascript" data-trim>  
function lastElementChild() {
    console.log(document.body.lastElementChild);
    console.log(document.body.childNodes.lastElementChild);
    console.log(document.body.childNodes[1].lastElementChild);
}
	</code>
	</pre>
					</section>
					<section>
						<h3>nextElementSibling (get only)</h3>
						<p>Содержит узел, который следует сразу за узлом, вызвавшим это свойство или null, если такового не существует</p>
						<img src="img/nextElementSibling.png" alt="" height="200">
						<pre><code class="hljs javascript" data-trim>  
function nextElement() {
    console.log(document.body.nextElementSibling);
    console.log(document.getElementById('container').children[0].nextElementSibling);
    console.log(document.body.childNodes[1].childNodes[2].nextElementSibling);
}
	</code>
	</pre>
					</section>
					<section>
						<h3>previousElementSibling (get only)</h3>
						<p>Содержит узел, который следует перед узлом, вызвавшим это свойство или null, если такового не существует</p>
						<img src="img/previousElementSibling.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>  
function prevElement() {
    console.log(document.body.previousElementSibling);
    console.log(document.getElementById('container').children[1].previousElementSibling);
    console.log(document.body.childNodes[1].childNodes[2].previousElementSibling);
}
	</code>
	</pre>
					</section>
					<section>
						<h3>parentElement (get only)</h3>
						<p>
							Возвращает родителя узла DOM Element, или null если узел не имеет родителя, или его родитель не DOM Element
						</p>
						<img src="img/parentelement.png" alt="">
						<pre>
					<code class="hljs javascript" data-trim="">
function parentElement(){
    console.log(document.getElementById('container').children[1].parentElement);
    console.log(document.body.childNodes[1].firstElementChild.parentElement);
}
					</code>
				</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Особые ссылки для таблиц</h2>
						<small>
							<table>
								<tbody>
									<tr>
										<td>table.rows</td>
										<td>коллекция строк TR таблицы</td>
									</tr>
									<tr>
										<td>table.caption/tHead/tFoot</td>
										<td>ссылки на элементы таблицы CAPTION, THEAD, TFOOT</td>
									</tr>
									<tr>
										<td>table.tBodies</td>
										<td>коллекция элементов таблицы TBODY, по спецификации их может быть несколько</td>
									</tr>
									<tr>
										<td>tbody.rows</td>
										<td>коллекция строк TR секции TBODY</td>
									</tr>
									<tr>
										<td>tr.cells</td>
										<td>коллекция ячеек TD/TH</td>
									</tr>
									<tr>
										<td>tr.sectionRowIndex</td>
										<td>номер строки в текущей секции THEAD/TBODY</td>
									</tr>
									<tr>
										<td>tr.rowIndex</td>
										<td>номер строки в таблице</td>
									</tr>
									<tr>
										<td>td.cellIndex</td>
										<td>номер ячейки в строке</td>
									</tr>
								</tbody>
							</table>
						</small>
					</section>
					<section>
						<h3>Пример таблицы</h3>
						<pre>
					<code class="hljs html" data-trim="">
&lt;table id="table"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Key&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tfoot&gt;
        &lt;tr&gt;
            &lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tfoot&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;A&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
					</code>
				</pre>
					</section>
					<section>
						<h3>table.rows</h3>
						<img src="img/table.rows.png" alt="">
						<pre>
					<code class="hljs javascript" data-trim>
function rows(){
    var table = document.getElementById('table');
    console.log(table.rows);
}
					</code>
				</pre>
					</section>
					<section>
						<h3>table.tBodies</h3>
						<img src="img/table.tbody.png" alt="">
						<pre>
					<code class="hljs javascript" data-trim>
function tbody() {
    var table = document.getElementById('table');
    console.log(table.tBodies);
}
					</code>
				</pre>
					</section>
					<section>
						<h3>row.cells</h3>
						<img src="img/table.cells.png" alt="">
						<pre>
					<code class="hljs javascript" data-trim>
function cells(){
    var row = document.getElementById('table').rows[0];
    console.log(row.cells);
}
					</code>
				</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Поиск элементов</h2>
						<ul>
							<li>getElementById</li>
							<li>getElementsByTagName</li>
							<li>getElementsByName</li>
							<li>getElementsByClassName</li>
							<li>querySelectorAll</li>
							<li>querySelector</li>
							<li>closest</li>
						</ul>
					</section>
					<section>
						<h3>getElementById</h3>
						<p>Оптимизация баузера (работает быстро). Внутреннее соответствие id -> элемент</p>
						<img src="img/document-getElementById.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
function getElementById(){
    console.log(document.getElementById('container'));
    console.log(document.getElementById('tag'));
}
						</code>
					</pre>
					</section>
					<section>
						<h3>getElementsByTagName</h3>
						<p>При изменении документа – изменяется и результат запроса</p>
						<img src="img/document-getElementsByTagName.png" alt="" height="300">
						<pre>
											<code class="hljs javascript" data-trim>
function getElementsByTagName(){
    console.log(document.getElementsByTagName('img'));
    console.log(document.getElementsByTagName('div'));
    console.log(document.getElementsByTagName('bla'));
}
						</code>
					</pre>
					</section>
					<section>
						<h3>getElementsByName</h3>
						<img src="img/document-getElementsByName.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
function getElementsByName() {
    console.log(document.getElementsByName('title__1'));
    console.log(document.getElementsByName('content'));
    console.log(document.getElementsByName('img'));
}
						</code>
					</pre>
					</section>
					<section>
						<h3>getElementsByClassName</h3>
						<img src="img/document-getelementbyclassname.png" alt="" height="350">
						<pre>
						<code class="hljs javascript" data-trim>
function getElementsByClassName() {
    console.log(document.getElementsByClassName('content'));
    console.log(document.getElementsByClassName('title'));
    console.log(document.getElementsByClassName('img'));
}
						</code>
					</pre>
					</section>
					<section>
						<h3>Оптимизация запросов getElementsBy...</h3>
						<p>Firefox + IE + Edge</p>
						<ol>
							<li>Перебрать подэлементы document.body в порядке их появления в поддереве</li>
							<li>Запоминать все найденные элементы во внутренней структуре данных, чтобы при повторном обращении обойтись без поиска</li>
						</ol>
					</section>
					<section>
						<h3>Пример</h3>
						<pre>
						<code class="hljs javascript" data-trim>
var elems = document.getElementsByTagName('div');
console.log(elems[0]);
console.log(elems[995]);
console.log(elems[500]);
console.log(elems.length);
						</code>
					</pre>
						<small>
							<ol>
								<li>Браузер создаёт пустую «живую коллекцию» elems, но ничего не ищет</li>
								<li>Перебирает элементы, пока не найдёт первый div. Запоминает его и возвращает</li>
								<li>Перебирает элементы дальше, пока не найдёт элемент с индексом 995. Запоминает все найденные</li>
								<li>Возвращает ранее заполненный элемент с индексом 500, без дополнительного поиска</li>
								<li>Продолжает обход поддерева с элемента, на котором остановился (995) и до конца. Запоминает найденные элементы и возвращает
									их количество</li>
							</ol>
						</small>
					</section>
					<section>
						<h3>Оптимизация запросов getElementsBy...</h3>
						<p>Webkit (Chrome + Safari + Opera)</p>
						<blockquote>
							Перебирает подэлементы body. Запоминает только последний найденный элемент, а также, по окончании перебора – длину коллекции
						</blockquote>
						<p>Отличия от предыдущего способа</p>
						<ul>
							<li>Кеширование используется меньше</li>
							<li>Запоминает только последний элемент</li>
							<li>Требует меньше памяти, но менее эффективнее при повторном доступе к предыдущим элементам</li>
							<li>Одинаково хорошо работает при последовательном переборе коллекции, без возврата к ранее выбранным</li>
						</ul>
					</section>
					<section>
						<h3>Пример</h3>
						<pre>
						<code class="hljs javascript" data-trim>
var elems = document.getElementsByTagName('div');
console.log(elems[0]);
console.log(elems[995]);
console.log(elems[500]);
console.log(elems.length);
						</code>
					</pre>
						<small>
							<ol>
								<li>Браузер создаёт пустую «живую коллекцию» elems. Пока ничего не ищет.</li>
								<li>Перебирает элементы, пока не найдёт первый div. Запоминает его и возвращает.</li>
								<li>Перебирает элементы дальше, пока не найдёт элемент с индексом 995. Запоминает его и возвращает.</li>
								<li>Браузер запоминает только последний найденный, поэтому не помнит об элементе 500. Нужно найти его перебором поддерева.
									Этот перебор можно начать либо с начала – вперед по поддереву, 500-й по счету) либо с элемента 995 – назад по поддереву,
									495-й по счету. Так как назад разница в индексах меньше, то браузер выбирает второй путь и идёт от 995-го назад
									495 раз. Запоминает теперь уже 500-й элемент и возвращает его.</li>
								<li>Продолжает обход поддерева с 500-го (не 995-го!) элемента и до конца. Запоминает число найденных элементов и возвращает
									его.
								</li>
							</ol>
						</small>
					</section>
					<section>
						<h3>querySelectorAll</h3>
						<p>Перебирает все подэлементы внутри элемента и проверяет каждый элемент на соответствие запросу</p>
						<p></p>
						<img src="img/document-queryAll.png" alt="" height="250">
						<pre>
						<code class="hljs javascript" data-trim>
//Результаты поиска сохраняются в кеше пока документ не изменится
function querySelectorAll(){
    console.log(document.querySelectorAll('#container'));
    console.log(document.querySelectorAll('div.content .title'));
}
						</code>
					</pre>
					</section>
					<section>
						<h3>querySelector</h3>
						<img src="img/document-query.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
function querySelector(){
    console.log(document.querySelector('#container'));
    console.log(document.querySelector('div.content .title'));
}
						</code>
					</pre>
					</section>
					<section>
						<h3>closest</h3>
						<img src="img/element-closest.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
function closest() {
    var link = document.getElementsByTagName('a')[0];
    console.log(link.closest('.content'));
    console.log(document.querySelector('#container'));
}
						</code>
					</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Основные свойства элементов</h2>
						<small>
							<table>
								<tbody>
									<tr>
										<td>attributes</td>
										<td>возвращает все атрибуты элемента</td>
									</tr>
									<tr>
										<td>classList</td>
										<td>возвращает псевдомассив DOMTokenList</td>
									</tr>
									<tr>
										<td>className</td>
										<td>возвращает/задает атрибута class элемента</td>
									</tr>
									<tr>
										<td>clientHeight</td>
										<td>CSSheight + CSSpadding - horizontalScrollHeight</td>
									</tr>
									<tr>
										<td>clientWidth</td>
										<td>CSSwidth + CSSpadding - horizontalScrollWidth</td>
									</tr>
									<tr>
										<td>data</td>
										<td>содержимое тестового узла</td>
									</tr>
									<tr>
										<td>firstElementChild</td>
										<td>возвращает первый дочерний элемент объекта</td>
									</tr>
									<tr>
										<td>id</td>
										<td>возвращает идентификатор элемента в DOM</td>
									</tr>
									<tr>
										<td>innerHTML</td>
										<td>возвращает/задает HTML-содержимое в виде строки</td>
									</tr>
									<tr>
										<td>hidden</td>
										<td>возвращает/задает видимость узла</td>
									</tr>
									<tr>
										<td>name</td>
										<td>возвращает/задает атрибут name</td>
									</tr>
									<tr>
										<td>outerHTML</td>
										<td>возвращает HTML (при записи заменяется на новый)</td>
									</tr>
									<tr>
										<td>scroll[Height...]</td>
										<td>высота контента, включая содержимое, невидимое из-за прокрутки</td>
									</tr>
									<tr>
										<td>shadowRoot</td>
										<td>внутренний DOM элемента</td>
									</tr>
									<tr>
										<td>tagName</td>
										<td>возвращает HTML-тег элемента</td>
									</tr>
								</tbody>
							</table>
						</small>
					</section>
					<section>
						<h3>attributes</h3>
						<img src="img/element-attributes.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
function attributes() {
    var container = document.getElementById('container');
    console.log(container.attributes);
    var link = document.getElementsByTagName('a')[0];
    console.log(link.attributes);
}
						</code>
					</pre>
					</section>
					<section>
						<h3>innerHTML & outerHTML</h3>
						<pre>
						<code class="hljs javascript" data-trim>
function html() {
    var container = document.getElementById('container');
    console.log(container.innerHTML);
    console.log(container.outerHTML);
	
    container.outerHTML = '<span>Text</span>';
    console.log(container.outerHTML);//empty
    console.log(document.getElementById('container'));//null
}
						</code>
					</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Основные методы элемента</h2>
						<table>
							<tbody>
								<tr>
									<td>hasAttribute</td>
									<td>проверяет наличие атрибута</td>
								</tr>
								<tr>
									<td>getAttribute</td>
									<td>получает значение атрибута</td>
								</tr>
								<tr>
									<td>setAttribute</td>
									<td>устанавливает атрибут</td>
								</tr>
								<tr>
									<td>removeAttribute</td>
									<td>удаляет атрибут</td>
								</tr>
								<tr>
									<td>contains</td>
									<td>проверка вложенности элементов</td>
								</tr>
								<tr>
									<td>matches</td>
									<td>проверка соответствия указанному css-селектору</td>
								</tr>
								<tr>
									<td>remove</td>
									<td>удаляет узел из дерева DOM</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h3>Работа с аттрибутами</h3>
						<pre>
						<code class="hljs javascript" data-trim>
function attribute() {
    var link = document.getElementsByTagName('a')[0];
	
    console.log(link.hasAttribute('href'));//true
    console.log(link.getAttribute('href'));//http://google.com
    console.log(link.getAttribute('class'));//link
	
    link.setAttribute('href', 'habrahabr.ru');
    console.log(link.getAttribute('href'));//habrahabr.ru
    link.removeAttribute('href');
}
						</code>
					</pre>
					</section>
					<section>
						<h3>Пример matches</h3>
						<pre>
						<code class="hljs javascript" data-trim>
function matches() {
    var link = document.getElementsByTagName('a')[0];
	
    console.log(link.matches('a'));//true
    console.log(link.matches('.link'));//true
    console.log(link.matches('#container a'));//true
    console.log(link.matches('.message a'));//true
    console.log(link.matches('a.message'));//false
}
						</code>
					</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Добавление и удаление узлов</h2>
						<table>
							<tbody>
								<tr>
									<td>createElement</td>
									<td>Создает новый элемент с указанным тегом</td>
								</tr>
								<tr>
									<td>createTextNode</td>
									<td>Создает новый текстовый узел с указанным текстом</td>
								</tr>
								<tr>
									<td>appendChild</td>
									<td>Добавляет elem в конец дочерних элементов parentElem</td>
								</tr>
								<tr>
									<td>insertBefore</td>
									<td>Вставляет elem в коллекцию детей parentElem, перед элементом nextSibling</td>
								</tr>
								<tr>
									<td>cloneNode</td>
									<td>Клонирование узлов</td>
								</tr>
								<tr>
									<td>removeChild</td>
									<td>Удаляет elem из списка детей parentElem</td>
								</tr>
								<tr>
									<td>replaceChild</td>
									<td>Среди детей parentElem удаляет elem и вставляет на его место newElem</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h3>Добавление элемента</h3>
						<img src="img/element-appendchild.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
function create(){
    var div = document.createElement('div');
    div.className = 'test';
    div.id = 'test';
    var container = document.querySelector('#container');
    container.appendChild(div);
}
						</code>
					</pre>
					</section>
					<section>
						<h3>Клонирование элемента</h3>
						<img src="img/element-clone.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
function clone(){
    var title = document.querySelector('.title');
    console.log(title.cloneNode());
    console.log(title.cloneNode(true));
}
						</code>
					</pre>
					</section>
					<section>
						<h3>Замена элемента</h3>
						<img src="img/element-replace.png" alt="">
						<pre>
						<code class="hljs javascript" data-trim>
function replace() {
    var title = document.querySelector('.title'),
        h3 = title.firstElementChild;
		
    var div = document.createElement('div');
    div.className = 'test';
    div.id = 'test';
    div.innerHTML = '<span>Test</span>';
    title.replaceChild(div, h3);
    console.log(title);
}
						</code>
					</pre>
					</section>
				</section>
				<section>
					<h1>События</h1>
				</section>
				<section>
					<h2>Браузерные события</h2>
					<small>
						<ul>
							<li>Событие – сигнал от браузера о том, что что-то произошло</li>
							<li>Тип события - строка, определяющая тип действия, вызвавшего событие (mousemove, click..)</li>
							<li>Цель события - объект, в котором возникло событие или с которым это событие связано(Window, Document и Element)</li>
							<li>Обработчик события - функция, которая обрабатывает, или откликается на событие</li>
							<li>Объект события - объект, связанный с определенным событием и содержащий информацию об этом событии. Объекты событий
								передаются функции обработчика события в виде аргумента</li>
							<li>Распространение события - процесс, в ходе которого браузер решает, в каких объектах следует вызвать обработчики событий
							</li>
						</ul>
					</small>
				</section>
				<section>
					<section>
						<h2>Обработчик события</h2>
						<blockquote>
							Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло. Именно благодаря обработчикам
							JavaScript-код может реагировать на действия посетителя
						</blockquote>
						<p>Существует несколько способов назначения обработчика события</p>
					</section>
					<section>
						<h3>
							Использование атрибута HTML
						</h3>
						<pre>
						<code class="hljs html" data-trim>
<element onclick="script"></element>

</code>
					</pre>
						<pre>
						<code class="hljs html" data-trim>
<input value="click me" onclick="alert('Click!')" type="button">
						</code>
					</pre>
						<pre>
						<code class="hljs html" data-trim>
<p id="text" onclick="setColor()">
    Click me to change my text color
</p>

function setColor() {
    document.getElementById("text").style.color = "red";
}
						</code>
					</pre>
					</section>
					<section>
						<h3>Использование свойства DOM-объекта</h3>
						<pre>
						<code class="hljs javascript" data-trim>
<input id="elem" type="button" value="Нажми" />
<script>
  elem.onclick = function() {
    alert( 'Спасибо' );
  };
</script>
						</code>
					</pre>
						<pre>
						<code class="hljs javascript" data-trim>
<input type="button" id="elem" onclick="alert('До')" value="Нажми" />
<script>
  elem.onclick = function() { //перезапишет существующий обработчик
    alert( 'После' ); //выведется только это
  };
</script>
						</code>
					</pre>
					</section>
					<section>
						<h3>Доступ к элементу через this</h3>
						<p class="text">Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором он сработал. Это можно использовать,
							чтобы получить свойства или изменить элемент</p>
						<pre>
						<code class="hljs html" data-trim>
<button onclick="alert(this.innerHTML)">Нажми</button>//Нажми
						</code>
					</pre>
					</section>
					<section>
						<h3>addEventListener</h3>
						<pre>
						<code class="hljs javascript" data-trim>
element.addEventListener(event, handler[, phase]);
						</code>
					</pre>
						<ul>
							<li>event - имя события, например click</li>
							<li>handler- ссылка на функцию, которую надо поставить обработчиком</li>
							<li>phase - необязательный аргумент, «фаза» (перехват/всплытие), на которой обработчик должен сработать</li>
						</ul>
						<pre>
						<code class="hljs javascript" data-trim>
elem.addEventListener( "click" , function() {
    console.log('Thank you!');
});
						</code>
					</pre>
						<pre>
						<code class="hljs javascript" data-trim>
function thanks(){
    console.log('Thank you!');
}
elem.addEventListener( "click" ,  thanks);
						</code>
					</pre>
					</section>
					<section>
						<h3>Еще пример addEventListener</h3>
						<pre>
						<code class="javascript hljs javascript" data-trim>
&lt;input id="elem" type="button" value="Нажми"/&gt;
&lt;script&gt;
  function handler1() {
    alert('Спасибо!');
  };

  function handler2() {
    alert('Спасибо ещё раз!');
  }

  elem.onclick = function() { alert("Привет"); };
  elem.addEventListener("click", handler1); //Спасибо!
  elem.addEventListener("click", handler2); //Спасибо ещё раз!
&lt;/script&gt;
						</code>
					</pre>
					</section>
					<section>
						<h3>removeEventListener</h3>
						<p>Передается таже функция-обработчик, которая была назначена на событие</p>
						<pre>
						<code class="hljs javascript" data-trim>
//передать те же аргументы, что были у addEventListener
element.removeEventListener(event, handler[, phase]);
						</code>
					</pre>
						<pre>
						<code class="hljs javascript" data-trim>
elem.addEventListener( "click" , function() {alert('Спасибо!')});
//....не сработает
elem.removeEventListener( "click", function() {alert('Спасибо!')});
						</code>
					</pre>
						<pre>
						<code class="hljs javascript" data-trim>
function handler() {
  alert( 'Спасибо!' );
}
input.addEventListener("click", handler);
//....
input.removeEventListener("click", handler);
						</code>
					</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Создание события</h2>
						<ul>
							<li>Event()</li>
							<li>EventTarget.dispatchEvent()</li>
							<li>CustomEvent()</li>
						</ul>
					</section>
					<section>
						<h3>Event</h3>
						<pre>
						<code class="hljs javascript" data-trim>
event = new Event(typeArg, eventInit);
						</code>
					</pre>
						<ul>
							<li>Тип события – может быть как своим, так и встроенным, к примеру "click"</li>
							<li>Флаги – объект вида { bubbles: true/false, cancelable: true/false }...</li>
						</ul>
						<pre>
						<code class="hljs javascript" data-trim>
var ev = new Event("look", {"bubbles":true, "cancelable":false});
document.dispatchEvent(ev);
						</code>
					</pre>
					</section>
					<section>
						<h3>dispatchEvent</h3>
						<ul>
							<li>Отправляет событие в общую систему событий</li>
							<li>Cобытие подчиняется тем же правилам поведения (захват и всплытие) как и непосредственно инициированные события</li>
						</ul>
						<pre>
					<code class="hljs javascript" data-trim>
cancelled = !target.dispatchEvent(event)
//event - объект события, который инициализируется
//target - используется для инициализации Event.target 
//и установки события, которое обработчик вызывает

//return - false если хотя бы один из обработчиков 
//этого события вызовал preventDefault
					</code>
	</pre>
						<pre>
						<code class="hljs html" data-trim="">
&lt;button id="elem" onclick="alert('Клик');"&gt;Автоклик&lt;/button&gt;
&lt;script&gt;
  var event = new Event("click");
  elem.dispatchEvent(event);
&lt;/script&gt;
						</code>
					</pre>
					</section>
					<section>
						<h3>CustomEvent</h3>
						<p>
							Идентичен Event(), НО у второго аргумента-объекта есть дополнительное свойство detail, в котором можно указывать дополнительную
							информацию
						</p>
						<pre>
						<code class="hljs html" data-trim>							
&lt;h1 id="elem"&gt;Element&lt;/h1&gt;

&lt;script&gt;
var elem = document.getElementById('elem');
  elem.addEventListener("hello", function(event) {
    console.log( event.detail.name );
  }, false);

  var event = new CustomEvent("hello", {
    detail: { name: "something" }
  });

  elem.dispatchEvent(event);
&lt;/script&gt;
						</code>
					</pre>
					</section>
				</section>
				<section>
					<h2>Типы событий</h2>
					<ul>
						<li>События мыши</li>
						<li>События документа Window</li>
						<li>События клавиатуры</li>
						<li>События формы и ЭУ</li>
						<li>События буфера обмена</li>
						<li>События перетаскивания</li>
						<li>События медиа</li>
						<li>События CSS</li>
					</ul>
				</section>
				<section>
					<section>
						<h2>Объект события</h2>
						<img src="img/event.png" alt="">
						<pre>
					<code class="hljs javascript" data-trim>
<form id="el1">
    <input type="submit" id="el2" value="Save">
</form>

<script>
function onClick(e) {
    console.log(e);
}
document.getElementById('el1').addEventListener('click', onClick);
</script>	
					</code>
				</pre>
					</section>
					<section>
						<h3>Основные свойства и методы</h3>
						<small>
							<table>
								<tbody>
									<tr>
										<td>type</td>
										<td>тип события</td>
									</tr>
									<tr>
										<td>currentTarget</td>
										<td>элемент, на котором сработал обработчик</td>
									</tr>
									<tr>
										<td>target</td>
										<td>целевой элемент (там, где произошло событие)</td>
									</tr>
									<tr>
										<td>bubbles</td>
										<td>является ли данное событие всплывающим</td>
									</tr>
									<tr>
										<td>cancelable</td>
										<td>является ли событие отменяемым</td>
									</tr>
									<tr>
										<td>isTrusted</td>
										<td>было ли событие инициировано действиями пользователя</td>
									</tr>
									<tr>
										<td>preventDefault()</td>
										<td>останавливает событие (если оно cancelable) без остановки всплытия</td>
									</tr>
									<tr>
										<td>stopImmediatePropagation()</td>
										<td>останавливает цепочку вызова событий для последующих слушателей DOM элемента и текущих событий</td>
									</tr>
									<tr>
										<td>stopPropagation()</td>
										<td>останавливает цепочку вызова событий для последующих слушателей DOM элемента (на текущем элементе все обработчики
											отработают)
										</td>
									</tr>
								</tbody>
							</table>
						</small>
					</section>
					<section>
						<h3>Всплытие событий</h3>
						<img src="img/event-bubling.jpg" alt="" height="400">
					</section>
					<section>
						<h3>Пример всплытия событий</h3>
						<img src="img/event5.png" alt="">
						<pre>
					<code class="hljs javascript" data-trim>
<form id="el1">
    <input type="button" id="el2" value="Save">
</form>

<script>
function onClick(e) {
    console.log(e);
}
var element = document.getElementById('el1');
element.addEventListener('click', onClick, true);
element.addEventListener('click', function(e){console.log(e);}, true);
document.getElementById('el2').addEventListener('click', onClick);
</script>
					</code>
				</pre>
					</section>
					<section>
						<h3>Метод stopImmediatePropagation</h3>
						<img src="img/event3.png" alt="">
						<pre>
					<code class="hljs javascript" data-trim>
<form id="el1">
    <input type="button" id="el2" value="Save">
</form>

<script>
function onClick(e) {
    console.log(e);
    e.stopImmediatePropagation();
}
document.getElementById('el1').addEventListener('click', onClick);
document.getElementById('el1').addEventListener('click', onClick);
document.getElementById('el2').addEventListener('click', onClick);
</script>
					</code>
				</pre>
					</section>
					<section>
						<h3>Метод stopPropagation</h3>
						<img src="img/event4.png" alt="">
						<pre>
					<code class="hljs javascript" data-trim>
<form id="el1">
    <input type="button" id="el2" value="Save">
</form>
<script>
function onClick(e) {
    console.log(e);
    e.stopPropagation();
}
var elem = document.getElementById('el1');
elem.addEventListener('click', onClick, true);
elem.addEventListener('click', function(e){console.log(e);}, true);
document.getElementById('el2').addEventListener('click', onClick);
</script>
					</code>
				</pre>
					</section>
					<section>
						<h3>Метод preventDefault</h3>
						<img src="img/event2.png" alt="">
						<pre>
					<code class="hljs javascript" data-trim>
<form id="el1">
	<input type="submit" id="el2" value="Save">
</form>
<script>
function onClick(e) {
    console.log(e);
    e.preventDefault();
    //return false;//любое значение кроме false
    //эквивалентно preventDefault + stopPropagation
}
document.getElementById('el1').addEventListener('click', onClick);
document.getElementById('el2').addEventListener('click', onClick);
</script>
					</code>
				</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>События мыши</h2>
						<small>
							<table>
								<tbody>
									<tr>
										<td>click</td>
										<td>нажатие на элемент левой кнопкой мыши</td>
									</tr>
									<tr>
										<td>dblclick</td>
										<td>двойное нажатие на элемент левой кнопкой мыши</td>
									</tr>
									<tr>
										<td>contextmenu</td>
										<td>нажатие на элемент правой кнопкой мыши</td>
									</tr>
									<tr>
										<td>mouseover</td>
										<td>при наведении мыши на элемент</td>
									</tr>
									<tr>
										<td>mousedown</td>
										<td>при нажатии мышью на элемент</td>
									</tr>
									<tr>
										<td>mouseup </td>
										<td>при отжатии мыши на элементе</td>
									</tr>
									<tr>
										<td>mousemove</td>
										<td>при движении мыши</td>
									</tr>
									<tr>
										<td>onwheel</td>
										<td>при передвижении колеса мыши над элементом</td>
									</tr>
								</tbody>
							</table>
						</small>
					</section>
					<section>
						<h3>Простой пример</h3>
						<pre>
					<code class="hljs html" data-trim>
<div id="test"></div>

<script>
  document.getElementById("test").addEventListener("click", function(ev) {
    ev.target.innerHTML = "click count: " + ev.detail;
	ev.target.classList.toggle("red");
  }, false);
</script>
					</code>
				</pre>
					</section>
					<section>
						<h3>Модификаторы shift, alt, ctrl, meta (Mac)</h3>
						<pre>
					<code class="hljs html" data-trim>	
<button>Alt+Shift+Кликни меня!</button>

<script>
  document.body.children[0].onclick = function(e) {
    if (!e.altKey || !e.shiftKey) return;
    alert( 'Ура!' );
  }
</script>
					</code>
				</pre>
					</section>
					<section>
						<h3>Координаты</h3>
						<pre>	
					<code class"hljs javascript" data-trim>
<input type="button" id="click" value="Click me">
<script>
    function onClick(e) {
        console.log(e.clientX);//относительно окна
        console.log(e.clientY);
        console.log(e.pageX); //относительно документа
        console.log(e.pageY);
    }
    document.getElementById('click').addEventListener('click', onClick);
</script>
					</code>
				</pre>
					</section>
					<section>
						<h3>Client[X,Y] vs Page[X, Y]</h3>
						<img src="img/pagevsclient.png" alt="">
					</section>
					<section>
						<h3>Получение информации о кнопке</h3>
						<pre><code class="hljs hyml" data-trim>
<input type="button" id="click" value="Click me">
<script>
	function onClick(e) {
        console.log(e.which);
        /*
        event.which == 1 – левая кнопка
        event.which == 2 – средняя кнопка
        event.which == 3 – правая кнопка
        */
    }

    document.getElementById('click')
    .addEventListener('click', onClick);
</script>
	</code>
	</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>События документа Window</h2>
						<table>
							<tbody>
								<tr>
									<td>DOMContentLoaded</td>
									<td>HTML загружен и обработан, DOM полностью построена и доступна</td>
								</tr>
								<tr>
									<td>load</td>
									<td>браузер загрузил все ресурсы</td>
								</tr>
								<tr>
									<td>beforeunload/unload</td>
									<td>при уходе со страницы</td>
								</tr>
								<tr>
									<td>resize</td>
									<td>браузер изменил размеры окна</td>
								</tr>
								<tr>
									<td>error</td>
									<td>при запуске/загрузке ресурса происходит ошибка</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h3>Пример DOMContentLoaded</h3>
						<pre>
					<code class="hljs javascript" data-trim>
&lt;script&gt;
  function ready() {
    console.log( 'DOM готов' );
    console.log( "Размеры картинки: " 
		+ img.offsetWidth + "x" 
		+ img.offsetHeight );
    //не дожидаемся загрузки картинки ( 0x0 )
  }

  document.addEventListener("DOMContentLoaded", ready);
&lt;/script&gt;
&lt;img id="img" src="/logos/doodles/2016/holidays-2016-2748273943.gif"&gt;
					</code>
				</pre>
					</section>
					<section>
						<h3>Пример load</h3>
						<pre>
					<code class="hljs html" data-trim>
&lt;script&gt;
  window.onload = function() {
    console.log('Документ и все ресурсы загружены');
  };
&lt;/script&gt;

&lt;iframe src="https://example.com/" style="height:60px"&gt;&lt;/iframe&gt;
&lt;script src="index.js"&gt;&lt;/script&gt;
					</code>
				</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>События клавиатуры</h2>
						<table>
							<tbody>
								<tr>
									<td>keyup</td>
									<td>отпускание клавиши</td>
								</tr>
								<tr>
									<td>keydown</td>
									<td>нажатие клавиши</td>
								</tr>
								<tr>
									<td>keypress</td>
									<td>приводит к появлению символа</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h3>Пример keydown</h3>
						<pre>
					<code class="hljs html" data-trim>
<input type="text" id="text">

<script>
    function onKeyUp(e) {
        e.target.style.background = (e.keyCode == 32)
        ? 'violet'
        : '';
    }
    document.getElementById('text').addEventListener('keyup', onKeyUp);
</script>
					</code>
				</pre>
					</section>
					<section>
						<h3>Кроссбраузерный подход</h3>
						<pre>
					<code class="hljs javascript" data-trim>
//event.type должен быть keypress
function getChar(event) {
  if (event.which == null) { //IE
    if (event.keyCode < 32) return null; //спец. символ
    return String.fromCharCode(event.keyCode)
  }

  if (event.which != 0 && event.charCode != 0) { //все кроме IE
    if (event.which < 32) return null; //спец. символ
    return String.fromCharCode(event.which); //остальные
  }

  return null; //спец. символ
}
//Код символа хранится в свойствах: charCode и which. 
//Не совместимость
					</code>
				</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>События форм и ЭУ</h2>
						<table>
							<tbody>
								<tr>
									<td>blur</td>
									<td>при потере элементов фокуса</td>
								</tr>
								<tr>
									<td>change</td>
									<td>по окончании изменении значения элемента формы</td>
								</tr>
								<tr>
									<td>focus</td>
									<td>при получении элементов фокуса</td>
								</tr>
								<tr>
									<td>invalid</td>
									<td>при получении элементом статуса invalid</td>
								</tr>
								<tr>
									<td>select</td>
									<td>при выборе пользователем элемента</td>
								</tr>
								<tr>
									<td>submit</td>
									<td>при отправке формы на сервер</td>
								</tr>
								<tr>
									<td>input</td>
									<td>срабатывает тут же при изменении значения текстового элемента</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h3>Change</h3>
						<blockquote>
							Для текстовых элементов означает, что событие произойдёт не при каждом вводе, а при потере фокуса
						</blockquote>
						<pre>
					<code class="hljs html" data-trim>
<input type="text" id="text">
<script>
    function onChange(e) {
        e.target.value += ';';
    }
    document.getElementById('text').addEventListener('change', onChange);
</script>
					</code>
				</pre>
					</section>
					<section>
						<h3>Invalid</h3>
						<pre>
					<code class="hljs html" data-trim>
<form>
    <input type="text" id="text" pattern=".{6,}" required>
    <input type="submit" value="Save">
</form>
    
<script>
    function onInvalid() {
        console.log('Must contain 6 or more characters');
    }
    document.getElementById('text').addEventListener('invalid', onInvalid);
</script>
					</code>
				</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>События буфера обмена</h2>
						<table>
							<tbody>
								<tr>
									<td>copy</td>
									<td>копирование значения</td>
								</tr>
								<tr>
									<td>paste</td>
									<td>вставки значения</td>
								</tr>
								<tr>
									<td>cut</td>
									<td>вырезании значения</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h3>DataTransfer</h3>
						<p>clipboardData использует объект dataTransfer</p>
						<pre>
							<code class="hljs javascript" data-trim>
void dataTransfer.setData(format, data);
//text/plain
//text/uri-list
//text/html
							</code>
						</pre>
					<pre>
						<code class="hljs javascript" data-trim>
DataTransfer.clearData([format]);
						</code>
				</pre>
				<pre>
					<code class="hljs javascript" data-trim>
void dataTransfer.setData(format, data);
					</code>
				</pre>
						<pre>
					<code class="hljs javascript" data-trim>
DOMString dataTransfer.getData(format);
					</code>
				</pre>
					</section>
					<section>
						<h3>Пример</h3>
						<pre>
						<code class="hljs html" data-trim>
&lt;input type="text" id="text"&gt;
&lt;script&gt;
    function onCopy(e) {
        e.clipboardData.setData('text/plain', 'Something');
    }
    document.getElementById('text').addEventListener('copy', onKeyUp);
&lt;/script&gt;
						</code>
					</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>
							События перетаскивания
						</h2>
						<table>
							<tbody>
								<tr>
									<td>drag</td>
									<td>при перетаскивании элемента</td>
								</tr>
								<tr>
									<td>dragstart</td>
									<td>когда элемент начинает перемещаться</td>
								</tr>
								<tr>
									<td>dragenter</td>
									<td>когда перемещаемый элемент попадает на элемент-назначение</td>
								</tr>
								<tr>
									<td>drop</td>
									<td>после отпускания элемента</td>
								</tr>
								<tr>
									<td>DataTransfer</td>
									<td>объект используется для хранения данных, перетаскиваемых мышью во время операции drag and drop</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h3>Алгоритм Drag’n’Drop</h3>
						<ol>
							<li>Отслеживаем нажатие кнопки мыши на переносимом элементе при помощи события mousedown</li>
							<li>При нажатии – подготовить элемент к перемещению</li>
							<li>Отслеживаем движение мыши через mousemove</li>
							<li>Передвигаем переносимый элемент на новые координаты путём смены left/top и position:absolute</li>
							<li>При отпускании кнопки мыши (mouseup) – остановить перенос элемента</li>
							<li>Дополнительные действия, связанные с окончанием Drag’n’Drop</li>
						</ol>
					</section>
					<section>
						<h3>Пример</h3>
						<pre>
					<code class="hljs html" data-trim>
&lt;div id="div1" ondrop="drop(event)" ondragover="allowDrop(event)"&gt;&lt;/div&gt;
&lt;img id="drag1" src="img.gif" draggable="true" ondragstart="drag(event)"&gt;

&lt;script&gt;
    function allowDrop(ev) {
        ev.preventDefault();
    }

    function drag(ev) {
        ev.dataTransfer.setData("text", ev.target.id);
    }

    function drop(ev) {
        ev.preventDefault();
        var data = ev.dataTransfer.getData("text");
        ev.target.appendChild(document.getElementById(data));
    }
&lt;/script&gt;
					</code>
				</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>События медиа (video, image, audio...)</h2>
						<table>
							<tbody>
								<tr>
									<td>onpause </td>
									<td>медиа-объект приостанавливает выполнение программно или в ответ на действие пользователя</td>
								</tr>
								<tr>
									<td>play</td>
									<td>медиа-объект готов к началу выполнению</td>
								</tr>
								<tr>
									<td>playing</td>
									<td>медиа-объект выполняется</td>
								</tr>
								<tr>
									<td>progress</td>
									<td>возникает при изменении состояния получения данных медиа-объектом</td>
								</tr>
								<tr>
									<td>volumechange</td>
									<td>возникает при изменении уровня громкости</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h3>Pause</h3>
						<pre>
					<code class="hljs html" data-trim>
&lt;video id="myVideo" width="320" height="176" controls&gt;
  &lt;source src="mov_bbb.mp4" type="video/mp4"&gt;
  &lt;source src="mov_bbb.ogg" type="video/ogg"&gt;
  Your browser does not support HTML5 video.
&lt;/video&gt;

&lt;script&gt;
var vid = document.getElementById("myVideo");
vid.onpause = function() {
    alert("The video has been paused");
};
&lt;/script&gt; 
					</code>
				</pre>
					</section>
					<section>
						<h3>volumechange</h3>
						<pre>
					<code class="hljs html" data-trim>
&lt;video controls id="myVideo"&gt;
  &lt;source src="mov_bbb.mp4" type="video/mp4"&gt;
  &lt;source src="mov_bbb.ogg" type="video/ogg"&gt;
  Your browser does not support HTML5 video.
&lt;/video&gt;

&lt;script&gt;
document.getElementById("myVideo").addEventListener("volumechange", myFunction);

function myFunction(e) {
   alert(e.target.volume);//[0-1]
   alert("The volume has been changed!");
}
&lt;/script&gt;
					</code>
				</pre>
					</section>
				</section>
				<section>
					<h2>События CSS</h2>
					<table>
						<tbody>
							<tr>
								<td>transitionend</td>
								<td>при завершении CSS-анимации</td>
							</tr>
						</tbody>
					</table>
					<pre>
						<code class="hljs javascript" data-trim>
/*
 * Прослушиваем событие transitionend на определенном элементе, 
 * Затем, вызваем определенную функцию (showMessage)
 */
function showMessage() {
    alert('Transition закончил свое выполнение');
}

var element = document.getElementById("slidingMenu");
element.addEventListener("transitionend", showMessage, false);
						</code>
					</pre>
				</section>
				<section>
					<h3>Вопрос: как структурировать огромное количество функций и переменных и избежать конфликтов и перезаписи информации?</h2>
						<img src="img/zoo.jpg" height="400" alt="">
				</section>
				<section>
					<section>
						<h2>Пространства имен</h2>
						<pre>
						<code class="hljs javascript" data-trim>
//Без пространства имен
function Person() {}
function Student() {}

var some_var = 1;
var module1 = {};

module1.data = {a: 1, b: 2};
var module2 = {};
					</code>
					</pre>
					</section>
					<section>
						<h3>Простой пример</h3>
						<pre>
						<code class="hljs javascript" data-trim>
var MYAPP = {};

MYAPP.Person = function () {};
MYAPP.Student = function () {};

MYAPP.some_var1 = 1;
MYAPP.some_var2 = 2;

MYAPP.modules = {};
MYAPP.modules.modulel = {};
MYAPP.modules.modulel.data = {
    a: 1,
    b: 2
};
MYAPP.modules.module2 = {};
					</code>
					</pre>
					</section>
					<section>
						<h3>Применение пространств имен</h3>
						<pre>
						<code class="hljs javascript" data-trim>
//применение функции пространства имен 
MYAPP.namespace('MYAPP.modules.module2'); 

//вызов эквивалентен следующей конструкции: 
var MYAPP = { 
    modules: { 
        module2: {} 
    }
}; 
					</code>
					</pre>
					</section>
					<section>
						<h3>Способ реализации</h3>
						<pre>
						<code class="hljs javascript" data-trim>
var MYAPP = MYAPP || {};
MYAPP.namespace = function (namespaceStr) {
    var parts = namespaceStr.split('.'),
        parent = MYAPP,
		i;
		
    //отбросить начальный префикс - имя глобального объекта 
    if (parts[0] === "MYAPP") {
        parts = parts.slice(1);
    }
	
    for (i = 0; i < parts.length; i += 1) {
        //создать свойство, если оно отсутствует 
        if (typeof parent[parts[i]] === "undefined") {
            parent[parts[i]] = {};
        }
        parent = parent[parts[i]];
    }
    return parent;
};
					</code>
					</pre>
					</section>
					<section>
						<h3>Пример работы</h3>
						<pre>
						<code class="hljs javascript" data-trim>
//присваиваение возвращаемого значение локальной переменной 
var module2 = MYAPP.namespace('MYAPP.modules.module2'); 
module2 === MYAPP.modules.module2; //true 

//отсутствие начального префикса 'MYAPP' 
MYAPP.namespace('modules.module51'); 

//создание глубоко вложенных пространств имен 
MYAPP.namespace('very.long.nested.property'); 
					</code>
					</pre>
					</section>
				</section>
				<section>
					<h2>Создание библиотек и модулей</h2>
					<pre>
					<code class="hljs javascript" data-trim>
;(function () {
    //приватные переменные
    var version = '0.0.1',
        faculties = ['EEF', 'ITF'];
    //приватные функции
    function Student(name) {
        this.name = name;
    }
    function addStudent(student) {}
    function assignStudentToFaculty(student, faculty) {}
    //основная функция библиотеки
    function bstu(params) {}
    //публичные переменные и функции
    bstu.Student = Student;
    bstu.FACULTY = faculties;
    //экспортируем публичные члены наружу из модуля
    window.BSTU = bstu;
}());
var student = new BSTU.Student('Max');
console.log(student.name);//Max
						</code>
				</pre>
				</section>
				<section>
					<h1>Event loop</h1>
				</section>
				<section>
					<h2>JS vs Потоки</h2>
					<blockquote>Javascript работает в одном потоке</blockquote>
					<ul>
						<li>Текущая функция не может быть приостановлена</li>
						<li>Текущая функция должна завершить свое выполнение до начала выполнения другой функции</li>
					</ul>
				</section>
				<section>
					<section>
						<h2>Модель событийного цикла</h2>
						<img src="img/lifecircle.svg" alt="" height="450">
					</section>
					<section>
						<h3>Общий стек вызовов функций</h3>
						<ul>
							<li>Вызов любой функции создает контекст выполнения</li>
							<li>При вызове вложенной функции создается новый контекст</li>
							<li>Старый контекст сохраняется в специальной структуре</li>
						</ul>
						<pre>
				<code class="hljs javascript" data-trim>
function f(b) {
  var a = 12;
  return a + b + 35;
}

function g(x) {
  var m = 4;
  return f(m * x);
}

g(21);
				</code>
			</pre>
					</section>
					<section>
						<h3>Алгоритм работы со стеком</h3>
						<ol>
							<li>При вызове
								<span class="highlight-blue">g</span>, создаётся область видимости, содержащая аргументы g и локальные переменные.
							</li>
							<li>При вызове
								<span class="highlight-blue">f</span>, создаётся вторая область видимости и помещается в стэк вперед первой, которая содержит аргументы f и её
								локальные переменные.</li>
							<li>Когда
								<span class="highlight-blue">f</span> возвращает результат, верхний элемент из стека удаляется.</li>
							<li>Когда
								<span class="highlight-blue">g</span> возвращает результат, контекст функции удаляется, и стэк будет пуст.</li>
						</ol>
					</section>
					<section>
						<h2>Куча</h2>
						<p>Объекты размещаются в куче. Куча — это ссылка на определённую неструктурированную области памяти</p>
					</section>
					<section>
						<h3>Очередь событий</h3>
						<blockquote>
							Очередь событий — это список событий, подлежащих обработке
						</blockquote>
						<ul>
							<li>Каждое событие связано с некоторой функцией</li>
							<li>Когда на стэке освобождается достаточно места, событие извлекается из очереди и обрабатывается</li>
							<li>Обработка события состоит в вызове этой функции (создание начального контекста выполнения)</li>
							<li>Обработка события заканчивается, когда стек становится пустым</li>
						</ul>
					</section>
					<section>
						<h3>Очередь событий</h3>
						<pre>
					<code class="hljs javascript" data-trim>
while(queue.waitForMessage()){
    queue.processNextMessage();
}
					</code>
				</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Особенности event loop</h2>
					</section>
					<section>
						<h3>Нулевые задержки</h3>
						<blockquote>
							Задержка – это минимальное время, которое требуется среде выполнения на обработку запроса
						</blockquote>
						<ul>
							<li>Нулевая задержка не дает гарантии, что обработчик выполнится через 0 миллисекунд</li>
							<li>Вызов setTimeout с аргументом 0 не завершится за указанное время</li>
							<li>Выполнение зависит от количества ожидающих в очереди задач</li>
						</ul>
					</section>
					<section>
						<h3>Никогда не блокируется</h3>
						<ul>
							<li>Поток выполнения никогда не блокируется</li>
							<li>Обработка I/O осуществляется с помощью событий и/или функций обратного вызова</li>
							<li>В момент ожидания события могут обрабатываться другие процессы (пользовательский ввод)</li>
							<li>Страница в браузере работает в одном потоке. Это значит, что браузер либо выполняет JS, либо рисует страницу (CSS-анимации,
								render, reflow)</li>
						</ul>
					</section>
					<section>
						<h3>Пример с timeline работы браузера</h3>
						<img src="img/network-panel.png" alt="">
					</section>
					<section>
						<h3>Смягчающее действие</h3>
						<p class="text">Если событие обрабатывается слишком долго, то приложение в это время не имеет возможности обработать действия пользователя
							(например, скролл, или клик). Internet Explorer, в таком случае, выводит сообщение "A script on this page is causing
							Internet Explorer to run slowly"</p>
					</section>
					<section>
						<h3>Таймеры в js</h3>
						<blockquote>
							Таймеры - это не sleep(), они создают события, которые используют Event Loop
						</blockquote>
						<ul>
							<li>setTimeout(function, timeout) - не ранее чем через timeout</li>
							<li>setInterval(function, timeout) - не чаще чем через timeout</li>
							<li>Точность интервалов не гарантирована</li>
							<li>Если таймер содержит долгие вычисления
								<span class="highlight-blue">while (true) {i++;}</span>, то он задержит Event Loop
							</li>
						</ul>
					</section>
					<section>
						<h3>Пример</h3>
						<pre>
						<code class="hljs javascript" data-trim="">
var timeMark = new Date;
setTimeout(function go() {
    //выполнится через 100 мс
    var diff = new Date - timeMark;
    console.log(diff);
    timeMark = new Date; 
	
    setTimeout(go, 100); //снова в очередь
}, 100); //положили go() в очередь через 100 мс
//101
//100
//102
//101
//103
//100
						</code>
					</pre>
					</section>
				</section>
				<section>
					<section>
						<h3>Event Loop простыми словами</h3>
						<img src="img/event-loop.png" alt="" height="550">
					</section>
					<section>
						<h3>Особенности</h3>
						<ul>
							<li>Основан на событиях</li>
							<li>События складываются в очередь</li>
							<li>Ждем события, затем его выполняем</li>
							<li>События могут генерировать события</li>
							<li>Завершается при опустошении очереди</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Пример event loop</h2>
						<pre>
						<code class="hljs javascript" data-trim>
$.get('/api/data.json', function(data) {
    getFile(data.filename, function() {
        alert('tada!');
    });
    showLoading('reading file');
});

showLoading('loading data');
						</code>
					</pre>
					</section>
					<section>
						<h3>Пример event loop: Запрос к серверу</h3>
						<pre>
						<code class="hljs javascript" data-trim>
$.get('/api/data.json', function(data) {//выполняется
    getFile(data.filename, function() {
        alert('tada!');
    });
    showLoading('reading file');
});

showLoading('loading data');//выполняется
						</code>
					</pre>
					</section>
					<section>
						<h3>Пример event loop: Ответ получен, функция читает файл</h3>
						<pre>
						<code class="hljs javascript" data-trim>
$.get('/api/data.json', function(data) {
    getFile(data.filename, function() {//выполняется
        alert('tada!');
    });
    showLoading('reading file');//выполняется
});

showLoading('loading data');
						</code>
					</pre>
					</section>
					<section>
						<h3>Пример event loop: Файл прочитан</h3>
						<pre>
						<code class="hljs javascript" data-trim>
$.get('/api/data.json', function(data) {
    getFile(data.filename, function() {
        alert('tada!');//выполняется
    });
    showLoading('reading file');
});

showLoading('loading data')
						</code>
					</pre>
					</section>
				</section>
				<section>
					<h2>Плюсы и минусы</h2>
					<table>
						<thead>
							<tr>
								<th>+</th>
								<th>-</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td style="width: 50%;">отсутствие состояния "гонки"</td>
								<td>процессороемкие задачи блокируют работу event loop</td>
							</tr>
							<tr>
								<td>веб-приложения не тратят время на ожидание ввода-вывода</td>
								<td>выполняется на 1 ядре, а остальные ядра простаивают</td>
							</tr>
							<tr>
								<td>относительно проста для освоения</td>
								<td>утечки памяти</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h2>Live-демонстрация</h2>
					<img src="img/event-loop-qr.png" alt="" height="450">
				</section>
				<section>
					<h2>Если не хватает параллельности</h2>
				</section>
				<section>
					<h2>Параллельное выполнение кода JavaScript</h2>
					<ul>
						<li>Dedicated workers (выделенные)</li>
						<li>SharedWorker (общие)</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Dedicated workers</h2>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Объекты запускаются в изолированном потоке</li>
						<li>Выполняемый код должен храниться в отдельном файле</li>
						<li>Создается путем вызова конструктора</li>
						<li>Использует DedicatedWorkerGlobalScope</li>
						<li>Если указанный файл существует, то браузер создаст новый поток объекта Worker, загружаемый асинхронно</li>
					</ul>
				</section>
				<section>
					<h3>Алгоритм работы</h3>
					<pre>
						<code class="hljs javascript" data-trim>
var worker = new Worker('task.js');//инициализация
						</code>
					</pre>
					<pre>
						<code class="hljs javascript" data-trim>
worker.postMessage(); //запуск
						</code>
					</pre>
					<pre>
						<code class="hljs javascript" data-trim>
worker.postMessage('Hello World');//отправление сообщения воркеру
						</code>
					</pre>
					<pre>
						<code class="hljs javascript" data-trim>
worker.terminate()//завершение работы
//или
this.close()//внутри объекта
						</code>
					</pre>
				</section>
				<section>
					<h3>Обмен сообщениями</h3>
					<p>Основной скрипт main.js</p>
					<pre>
						<code class="hljs javascript" data-trim>
var commandStop = 'Stop';
var worker = new Worker("worker.js");
					
worker.addEventListener('message', function(e) {
    console.log('Worker said: ', e.data);

    if(e.data === commandStop){
        worker.terminate();
    }
}, false);

worker.postMessage('Hello World'); 
						</code>
					</pre>
				</section>
				<section>
					<h3>Обмен сообщениями</h3>
					<p>Второй скрипт worker.js</p>
					<pre>
						<code class="hljs javascript" data-trim>
var self = this;

self.addEventListener('message', function(e) {
  console.log('Main said: ', e.data);
}, false);

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
};

setInterval(function(){
    var number = getRandomInt(0, 10);
    if(number === 5){
        self.postMessage('Stop');
        //self.close();
    }else{
        self.postMessage(number);
    }
}, 1000);
						</code>
					</pre>
				</section>
				<section>
					<h3>Результат</h3>
					<pre>
						<code class="hljs html" data-trim>
Main said:  Hello World
Worker said:  8
Worker said:  0
Worker said:  1
Worker said:  7
Worker said:  Stop
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>SharedWorker</h2>
					<blockquote>
						Воркеры, которые могут использоваться несколькими скриптами совместно, работающими в разных окнах, IFrames и т.д. в пределах одного домена, что и воркер. Они должны связываться через активный порт (MessagePort)
					</blockquote>
					<ul>
						<li>Создается путем вызова конструктора</li>
						<li>Идентифицируется по URL. Можно создать второй воркер из одного файла, добавив параметр в URL (worker.js?random=100)</li>
						<li>Работает с различными окнами, фреймами и файлами</li>
						<li>Используют SharedWorkerGlobalScope</li>
					</ul>
				</section>
				<section>
					<h3>Алгоритм работы</h3>
					<pre>
						<code class="hljs javascript" data-trim>
var worker = new SharedWorker("worker.js");
						</code>
					</pre>
					<pre>
						<code class="hljs javascript" data-trim>
worker.port.start();//вызывается в главном потоке
this.port.start();//вызывается в рабочем потоке
						</code>
					</pre>
					<pre>
						<code class="hljs javascript" data-trim>
worker.port.postMessage('Hello World');
//отправление сообщения воркеру

this.port.postMessage('Hello World');
//отправление сообщения основному потоку
						</code>
					</pre>
					<pre>
						<code class="hljs javascript" data-trim>
worker.port.close()//завершение работы
//или
this.port.close()//внутри объекта
						</code>
					</pre>
				</section>
				<section>
					<h3>Передача сообщений</h3>
					<p>Основной скрипт main.js</p>
					<pre>
						<code class="hljs javascript" data-trim>
var commandStop = 'Stop';
var worker = new SharedWorker("worker.js");

worker.port.addEventListener('message', function(e) {
    console.log('Worker said: ', e.data);
		  
    if(e.data === commandStop){
        worker.port.close();
    }
}, false);

worker.port.start();
worker.port.postMessage('Hello world');
						</code>
					</pre>
				</section>
				<section>
					<h3>Передача сообщений</h3>
					<p>Второй скрипт worker.js</p>
					<pre>
						<code class="hljs javascript" data-trim>
var self = this, port = null;

self.addEventListener("connect", function (e) {
    port = e.ports[0];

    port.addEventListener('message', function (e) {
        console.log('Main said: ', e.data);
    }, false);

    setInterval(sendMessage, 1000);
});

function sendMessage() {
    var number = getRandomInt(0, 10);

    if (number === 5) {
        port.postMessage('Stop');
        //port.close();
    } else {
        port.postMessage(number);
    }
}

function getRandomInt(min, max) {
	return Math.floor(Math.random() * (max - min)) + min;
};
						</code>
					</pre>
				</section>
				<section>
					<h3>Результат</h3>
					<pre>
						<code class="hljs javascript" data-trim>
Worker said:  2
Worker said:  4
Worker said:  2
Worker said:  9
Worker said:  3
Worker said:  0
Worker said:  7
Worker said:  Stop
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h2>Web Worker имеет доступ к:</h2>
				<ul>
					<li>Объект navigator</li>
					<li>Объект location (только чтение)</li>
					<li>XMLHttpRequest</li>
					<li>Таймеры (setTimeout/setInterval)</li>
					<li>Кэш приложений</li>
					<li>Импорт внешних скриптов (метод importScripts)</li>
					<li>Создание других объектов Web Worker</li>
				</ul>
			</section>
			<section>
				<h2>Web Worker не имеет доступа к:</h2>
				<ul>
					<li>Модель DOM</li>
					<li>Объект window</li>
					<li>Объект document</li>
					<li>Объект parent</li>
				</ul>
			</section>
			<section>
				<h2 class="header-hide">Спасибо за внимание</h2>
				<img src="img/thanks.jpg" alt="" height="600">
			</section>
		</div>
	</div>
	<aside id="presentable-icon" class="revealjs">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>